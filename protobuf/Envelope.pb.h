// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Envelope.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Envelope_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Envelope_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "AppMetadata.pb.h"
#include "CslValidation.pb.h"
#include "AddPlane.pb.h"
#include "ChangePlaneModel.pb.h"
#include "PositionUpdate.pb.h"
#include "DeletePlane.pb.h"
#include "NetworkConnected.pb.h"
#include "NetworkDisconnected.pb.h"
#include "AirplaneConfig.pb.h"
#include "NearbyControllers.pb.h"
#include "PrivateMessageReceived.pb.h"
#include "PrivateMessageSent.pb.h"
#include "SetTransponder.pb.h"
#include "FastPositionUpdate.pb.h"
#include "PlaneAddedToSim.pb.h"
#include "PlaneRemovedFromSim.pb.h"
#include "SetRadioStack.pb.h"
#include "RequestControllerInfo.pb.h"
#include "TriggerDisconnect.pb.h"
#include "TextMessageReceived.pb.h"
#include "TextMessageSent.pb.h"
#include "ServerMessageReceived.pb.h"
#include "MetarReceived.pb.h"
#include "RequestMetar.pb.h"
#include "WallopSent.pb.h"
#include "BroadcastMessageReceived.pb.h"
#include "InfoMessagePosted.pb.h"
#include "NotePosted.pb.h"
#include "SimulatorConnectionState.pb.h"
#include "AppConfig.pb.h"
#include "RadioStack.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Envelope_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Envelope_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Envelope_2eproto;
namespace xpilot {
class Envelope;
struct EnvelopeDefaultTypeInternal;
extern EnvelopeDefaultTypeInternal _Envelope_default_instance_;
}  // namespace xpilot
PROTOBUF_NAMESPACE_OPEN
template<> ::xpilot::Envelope* Arena::CreateMaybeMessage<::xpilot::Envelope>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace xpilot {

// ===================================================================

class Envelope final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xpilot.Envelope) */ {
 public:
  inline Envelope() : Envelope(nullptr) {}
  ~Envelope() override;
  explicit constexpr Envelope(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Envelope(const Envelope& from);
  Envelope(Envelope&& from) noexcept
    : Envelope() {
    *this = ::std::move(from);
  }

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline Envelope& operator=(Envelope&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Envelope& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kPositionUpdate = 2,
    kFastPositionUpdate = 3,
    kAirplaneConfig = 4,
    kAddPlane = 5,
    kPlaneAddedToSim = 6,
    kChangePlaneModel = 7,
    kDeletePlane = 8,
    kPrivateMessageReceived = 9,
    kPrivateMessageSent = 10,
    kTextMessageReceived = 11,
    kTextMessageSent = 12,
    kNetworkConnected = 13,
    kNetworkDisconnected = 14,
    kNearbyControllers = 15,
    kSetTransponder = 16,
    kSetRadiostack = 17,
    kAppMetdata = 18,
    kCslValidation = 19,
    kRequestControllerInfo = 20,
    kTriggerDisconnect = 21,
    kPlaneRemovedFromSim = 22,
    kServerMessageReceived = 23,
    kRequestMetar = 24,
    kMetarReceived = 25,
    kWallopSent = 26,
    kBroadcastMessageReceived = 27,
    kInfoMessagePosted = 28,
    kNotePosted = 29,
    kSimulatorConnectionState = 30,
    kAppConfig = 31,
    kRadioStack = 32,
    EVENT_NOT_SET = 0,
  };

  static inline const Envelope* internal_default_instance() {
    return reinterpret_cast<const Envelope*>(
               &_Envelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Envelope& a, Envelope& b) {
    a.Swap(&b);
  }
  inline void Swap(Envelope* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Envelope* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Envelope* New() const final {
    return new Envelope();
  }

  Envelope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Envelope>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Envelope* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xpilot.Envelope";
  }
  protected:
  explicit Envelope(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kPositionUpdateFieldNumber = 2,
    kFastPositionUpdateFieldNumber = 3,
    kAirplaneConfigFieldNumber = 4,
    kAddPlaneFieldNumber = 5,
    kPlaneAddedToSimFieldNumber = 6,
    kChangePlaneModelFieldNumber = 7,
    kDeletePlaneFieldNumber = 8,
    kPrivateMessageReceivedFieldNumber = 9,
    kPrivateMessageSentFieldNumber = 10,
    kTextMessageReceivedFieldNumber = 11,
    kTextMessageSentFieldNumber = 12,
    kNetworkConnectedFieldNumber = 13,
    kNetworkDisconnectedFieldNumber = 14,
    kNearbyControllersFieldNumber = 15,
    kSetTransponderFieldNumber = 16,
    kSetRadiostackFieldNumber = 17,
    kAppMetdataFieldNumber = 18,
    kCslValidationFieldNumber = 19,
    kRequestControllerInfoFieldNumber = 20,
    kTriggerDisconnectFieldNumber = 21,
    kPlaneRemovedFromSimFieldNumber = 22,
    kServerMessageReceivedFieldNumber = 23,
    kRequestMetarFieldNumber = 24,
    kMetarReceivedFieldNumber = 25,
    kWallopSentFieldNumber = 26,
    kBroadcastMessageReceivedFieldNumber = 27,
    kInfoMessagePostedFieldNumber = 28,
    kNotePostedFieldNumber = 29,
    kSimulatorConnectionStateFieldNumber = 30,
    kAppConfigFieldNumber = 31,
    kRadioStackFieldNumber = 32,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .xpilot.PositionUpdate position_update = 2;
  bool has_position_update() const;
  private:
  bool _internal_has_position_update() const;
  public:
  void clear_position_update();
  const ::xpilot::PositionUpdate& position_update() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::PositionUpdate* release_position_update();
  ::xpilot::PositionUpdate* mutable_position_update();
  void set_allocated_position_update(::xpilot::PositionUpdate* position_update);
  private:
  const ::xpilot::PositionUpdate& _internal_position_update() const;
  ::xpilot::PositionUpdate* _internal_mutable_position_update();
  public:
  void unsafe_arena_set_allocated_position_update(
      ::xpilot::PositionUpdate* position_update);
  ::xpilot::PositionUpdate* unsafe_arena_release_position_update();

  // .xpilot.FastPositionUpdate fast_position_update = 3;
  bool has_fast_position_update() const;
  private:
  bool _internal_has_fast_position_update() const;
  public:
  void clear_fast_position_update();
  const ::xpilot::FastPositionUpdate& fast_position_update() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::FastPositionUpdate* release_fast_position_update();
  ::xpilot::FastPositionUpdate* mutable_fast_position_update();
  void set_allocated_fast_position_update(::xpilot::FastPositionUpdate* fast_position_update);
  private:
  const ::xpilot::FastPositionUpdate& _internal_fast_position_update() const;
  ::xpilot::FastPositionUpdate* _internal_mutable_fast_position_update();
  public:
  void unsafe_arena_set_allocated_fast_position_update(
      ::xpilot::FastPositionUpdate* fast_position_update);
  ::xpilot::FastPositionUpdate* unsafe_arena_release_fast_position_update();

  // .xpilot.AirplaneConfig airplane_config = 4;
  bool has_airplane_config() const;
  private:
  bool _internal_has_airplane_config() const;
  public:
  void clear_airplane_config();
  const ::xpilot::AirplaneConfig& airplane_config() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::AirplaneConfig* release_airplane_config();
  ::xpilot::AirplaneConfig* mutable_airplane_config();
  void set_allocated_airplane_config(::xpilot::AirplaneConfig* airplane_config);
  private:
  const ::xpilot::AirplaneConfig& _internal_airplane_config() const;
  ::xpilot::AirplaneConfig* _internal_mutable_airplane_config();
  public:
  void unsafe_arena_set_allocated_airplane_config(
      ::xpilot::AirplaneConfig* airplane_config);
  ::xpilot::AirplaneConfig* unsafe_arena_release_airplane_config();

  // .xpilot.AddPlane add_plane = 5;
  bool has_add_plane() const;
  private:
  bool _internal_has_add_plane() const;
  public:
  void clear_add_plane();
  const ::xpilot::AddPlane& add_plane() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::AddPlane* release_add_plane();
  ::xpilot::AddPlane* mutable_add_plane();
  void set_allocated_add_plane(::xpilot::AddPlane* add_plane);
  private:
  const ::xpilot::AddPlane& _internal_add_plane() const;
  ::xpilot::AddPlane* _internal_mutable_add_plane();
  public:
  void unsafe_arena_set_allocated_add_plane(
      ::xpilot::AddPlane* add_plane);
  ::xpilot::AddPlane* unsafe_arena_release_add_plane();

  // .xpilot.PlaneAddedToSim plane_added_to_sim = 6;
  bool has_plane_added_to_sim() const;
  private:
  bool _internal_has_plane_added_to_sim() const;
  public:
  void clear_plane_added_to_sim();
  const ::xpilot::PlaneAddedToSim& plane_added_to_sim() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::PlaneAddedToSim* release_plane_added_to_sim();
  ::xpilot::PlaneAddedToSim* mutable_plane_added_to_sim();
  void set_allocated_plane_added_to_sim(::xpilot::PlaneAddedToSim* plane_added_to_sim);
  private:
  const ::xpilot::PlaneAddedToSim& _internal_plane_added_to_sim() const;
  ::xpilot::PlaneAddedToSim* _internal_mutable_plane_added_to_sim();
  public:
  void unsafe_arena_set_allocated_plane_added_to_sim(
      ::xpilot::PlaneAddedToSim* plane_added_to_sim);
  ::xpilot::PlaneAddedToSim* unsafe_arena_release_plane_added_to_sim();

  // .xpilot.ChangePlaneModel change_plane_model = 7;
  bool has_change_plane_model() const;
  private:
  bool _internal_has_change_plane_model() const;
  public:
  void clear_change_plane_model();
  const ::xpilot::ChangePlaneModel& change_plane_model() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::ChangePlaneModel* release_change_plane_model();
  ::xpilot::ChangePlaneModel* mutable_change_plane_model();
  void set_allocated_change_plane_model(::xpilot::ChangePlaneModel* change_plane_model);
  private:
  const ::xpilot::ChangePlaneModel& _internal_change_plane_model() const;
  ::xpilot::ChangePlaneModel* _internal_mutable_change_plane_model();
  public:
  void unsafe_arena_set_allocated_change_plane_model(
      ::xpilot::ChangePlaneModel* change_plane_model);
  ::xpilot::ChangePlaneModel* unsafe_arena_release_change_plane_model();

  // .xpilot.DeletePlane delete_plane = 8;
  bool has_delete_plane() const;
  private:
  bool _internal_has_delete_plane() const;
  public:
  void clear_delete_plane();
  const ::xpilot::DeletePlane& delete_plane() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::DeletePlane* release_delete_plane();
  ::xpilot::DeletePlane* mutable_delete_plane();
  void set_allocated_delete_plane(::xpilot::DeletePlane* delete_plane);
  private:
  const ::xpilot::DeletePlane& _internal_delete_plane() const;
  ::xpilot::DeletePlane* _internal_mutable_delete_plane();
  public:
  void unsafe_arena_set_allocated_delete_plane(
      ::xpilot::DeletePlane* delete_plane);
  ::xpilot::DeletePlane* unsafe_arena_release_delete_plane();

  // .xpilot.PrivateMessageReceived private_message_received = 9;
  bool has_private_message_received() const;
  private:
  bool _internal_has_private_message_received() const;
  public:
  void clear_private_message_received();
  const ::xpilot::PrivateMessageReceived& private_message_received() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::PrivateMessageReceived* release_private_message_received();
  ::xpilot::PrivateMessageReceived* mutable_private_message_received();
  void set_allocated_private_message_received(::xpilot::PrivateMessageReceived* private_message_received);
  private:
  const ::xpilot::PrivateMessageReceived& _internal_private_message_received() const;
  ::xpilot::PrivateMessageReceived* _internal_mutable_private_message_received();
  public:
  void unsafe_arena_set_allocated_private_message_received(
      ::xpilot::PrivateMessageReceived* private_message_received);
  ::xpilot::PrivateMessageReceived* unsafe_arena_release_private_message_received();

  // .xpilot.PrivateMessageSent private_message_sent = 10;
  bool has_private_message_sent() const;
  private:
  bool _internal_has_private_message_sent() const;
  public:
  void clear_private_message_sent();
  const ::xpilot::PrivateMessageSent& private_message_sent() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::PrivateMessageSent* release_private_message_sent();
  ::xpilot::PrivateMessageSent* mutable_private_message_sent();
  void set_allocated_private_message_sent(::xpilot::PrivateMessageSent* private_message_sent);
  private:
  const ::xpilot::PrivateMessageSent& _internal_private_message_sent() const;
  ::xpilot::PrivateMessageSent* _internal_mutable_private_message_sent();
  public:
  void unsafe_arena_set_allocated_private_message_sent(
      ::xpilot::PrivateMessageSent* private_message_sent);
  ::xpilot::PrivateMessageSent* unsafe_arena_release_private_message_sent();

  // .xpilot.TextMessageReceived text_message_received = 11;
  bool has_text_message_received() const;
  private:
  bool _internal_has_text_message_received() const;
  public:
  void clear_text_message_received();
  const ::xpilot::TextMessageReceived& text_message_received() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::TextMessageReceived* release_text_message_received();
  ::xpilot::TextMessageReceived* mutable_text_message_received();
  void set_allocated_text_message_received(::xpilot::TextMessageReceived* text_message_received);
  private:
  const ::xpilot::TextMessageReceived& _internal_text_message_received() const;
  ::xpilot::TextMessageReceived* _internal_mutable_text_message_received();
  public:
  void unsafe_arena_set_allocated_text_message_received(
      ::xpilot::TextMessageReceived* text_message_received);
  ::xpilot::TextMessageReceived* unsafe_arena_release_text_message_received();

  // .xpilot.TextMessageSent text_message_sent = 12;
  bool has_text_message_sent() const;
  private:
  bool _internal_has_text_message_sent() const;
  public:
  void clear_text_message_sent();
  const ::xpilot::TextMessageSent& text_message_sent() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::TextMessageSent* release_text_message_sent();
  ::xpilot::TextMessageSent* mutable_text_message_sent();
  void set_allocated_text_message_sent(::xpilot::TextMessageSent* text_message_sent);
  private:
  const ::xpilot::TextMessageSent& _internal_text_message_sent() const;
  ::xpilot::TextMessageSent* _internal_mutable_text_message_sent();
  public:
  void unsafe_arena_set_allocated_text_message_sent(
      ::xpilot::TextMessageSent* text_message_sent);
  ::xpilot::TextMessageSent* unsafe_arena_release_text_message_sent();

  // .xpilot.NetworkConnected network_connected = 13;
  bool has_network_connected() const;
  private:
  bool _internal_has_network_connected() const;
  public:
  void clear_network_connected();
  const ::xpilot::NetworkConnected& network_connected() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::NetworkConnected* release_network_connected();
  ::xpilot::NetworkConnected* mutable_network_connected();
  void set_allocated_network_connected(::xpilot::NetworkConnected* network_connected);
  private:
  const ::xpilot::NetworkConnected& _internal_network_connected() const;
  ::xpilot::NetworkConnected* _internal_mutable_network_connected();
  public:
  void unsafe_arena_set_allocated_network_connected(
      ::xpilot::NetworkConnected* network_connected);
  ::xpilot::NetworkConnected* unsafe_arena_release_network_connected();

  // .xpilot.NetworkDisconnected network_disconnected = 14;
  bool has_network_disconnected() const;
  private:
  bool _internal_has_network_disconnected() const;
  public:
  void clear_network_disconnected();
  const ::xpilot::NetworkDisconnected& network_disconnected() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::NetworkDisconnected* release_network_disconnected();
  ::xpilot::NetworkDisconnected* mutable_network_disconnected();
  void set_allocated_network_disconnected(::xpilot::NetworkDisconnected* network_disconnected);
  private:
  const ::xpilot::NetworkDisconnected& _internal_network_disconnected() const;
  ::xpilot::NetworkDisconnected* _internal_mutable_network_disconnected();
  public:
  void unsafe_arena_set_allocated_network_disconnected(
      ::xpilot::NetworkDisconnected* network_disconnected);
  ::xpilot::NetworkDisconnected* unsafe_arena_release_network_disconnected();

  // .xpilot.NearbyControllers nearby_controllers = 15;
  bool has_nearby_controllers() const;
  private:
  bool _internal_has_nearby_controllers() const;
  public:
  void clear_nearby_controllers();
  const ::xpilot::NearbyControllers& nearby_controllers() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::NearbyControllers* release_nearby_controllers();
  ::xpilot::NearbyControllers* mutable_nearby_controllers();
  void set_allocated_nearby_controllers(::xpilot::NearbyControllers* nearby_controllers);
  private:
  const ::xpilot::NearbyControllers& _internal_nearby_controllers() const;
  ::xpilot::NearbyControllers* _internal_mutable_nearby_controllers();
  public:
  void unsafe_arena_set_allocated_nearby_controllers(
      ::xpilot::NearbyControllers* nearby_controllers);
  ::xpilot::NearbyControllers* unsafe_arena_release_nearby_controllers();

  // .xpilot.SetTransponder set_transponder = 16;
  bool has_set_transponder() const;
  private:
  bool _internal_has_set_transponder() const;
  public:
  void clear_set_transponder();
  const ::xpilot::SetTransponder& set_transponder() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::SetTransponder* release_set_transponder();
  ::xpilot::SetTransponder* mutable_set_transponder();
  void set_allocated_set_transponder(::xpilot::SetTransponder* set_transponder);
  private:
  const ::xpilot::SetTransponder& _internal_set_transponder() const;
  ::xpilot::SetTransponder* _internal_mutable_set_transponder();
  public:
  void unsafe_arena_set_allocated_set_transponder(
      ::xpilot::SetTransponder* set_transponder);
  ::xpilot::SetTransponder* unsafe_arena_release_set_transponder();

  // .xpilot.SetRadioStack set_radiostack = 17;
  bool has_set_radiostack() const;
  private:
  bool _internal_has_set_radiostack() const;
  public:
  void clear_set_radiostack();
  const ::xpilot::SetRadioStack& set_radiostack() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::SetRadioStack* release_set_radiostack();
  ::xpilot::SetRadioStack* mutable_set_radiostack();
  void set_allocated_set_radiostack(::xpilot::SetRadioStack* set_radiostack);
  private:
  const ::xpilot::SetRadioStack& _internal_set_radiostack() const;
  ::xpilot::SetRadioStack* _internal_mutable_set_radiostack();
  public:
  void unsafe_arena_set_allocated_set_radiostack(
      ::xpilot::SetRadioStack* set_radiostack);
  ::xpilot::SetRadioStack* unsafe_arena_release_set_radiostack();

  // .xpilot.AppMetadata app_metdata = 18;
  bool has_app_metdata() const;
  private:
  bool _internal_has_app_metdata() const;
  public:
  void clear_app_metdata();
  const ::xpilot::AppMetadata& app_metdata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::AppMetadata* release_app_metdata();
  ::xpilot::AppMetadata* mutable_app_metdata();
  void set_allocated_app_metdata(::xpilot::AppMetadata* app_metdata);
  private:
  const ::xpilot::AppMetadata& _internal_app_metdata() const;
  ::xpilot::AppMetadata* _internal_mutable_app_metdata();
  public:
  void unsafe_arena_set_allocated_app_metdata(
      ::xpilot::AppMetadata* app_metdata);
  ::xpilot::AppMetadata* unsafe_arena_release_app_metdata();

  // .xpilot.CslValidation csl_validation = 19;
  bool has_csl_validation() const;
  private:
  bool _internal_has_csl_validation() const;
  public:
  void clear_csl_validation();
  const ::xpilot::CslValidation& csl_validation() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::CslValidation* release_csl_validation();
  ::xpilot::CslValidation* mutable_csl_validation();
  void set_allocated_csl_validation(::xpilot::CslValidation* csl_validation);
  private:
  const ::xpilot::CslValidation& _internal_csl_validation() const;
  ::xpilot::CslValidation* _internal_mutable_csl_validation();
  public:
  void unsafe_arena_set_allocated_csl_validation(
      ::xpilot::CslValidation* csl_validation);
  ::xpilot::CslValidation* unsafe_arena_release_csl_validation();

  // .xpilot.RequestControllerInfo request_controller_info = 20;
  bool has_request_controller_info() const;
  private:
  bool _internal_has_request_controller_info() const;
  public:
  void clear_request_controller_info();
  const ::xpilot::RequestControllerInfo& request_controller_info() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::RequestControllerInfo* release_request_controller_info();
  ::xpilot::RequestControllerInfo* mutable_request_controller_info();
  void set_allocated_request_controller_info(::xpilot::RequestControllerInfo* request_controller_info);
  private:
  const ::xpilot::RequestControllerInfo& _internal_request_controller_info() const;
  ::xpilot::RequestControllerInfo* _internal_mutable_request_controller_info();
  public:
  void unsafe_arena_set_allocated_request_controller_info(
      ::xpilot::RequestControllerInfo* request_controller_info);
  ::xpilot::RequestControllerInfo* unsafe_arena_release_request_controller_info();

  // .xpilot.TriggerDisconnect trigger_disconnect = 21;
  bool has_trigger_disconnect() const;
  private:
  bool _internal_has_trigger_disconnect() const;
  public:
  void clear_trigger_disconnect();
  const ::xpilot::TriggerDisconnect& trigger_disconnect() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::TriggerDisconnect* release_trigger_disconnect();
  ::xpilot::TriggerDisconnect* mutable_trigger_disconnect();
  void set_allocated_trigger_disconnect(::xpilot::TriggerDisconnect* trigger_disconnect);
  private:
  const ::xpilot::TriggerDisconnect& _internal_trigger_disconnect() const;
  ::xpilot::TriggerDisconnect* _internal_mutable_trigger_disconnect();
  public:
  void unsafe_arena_set_allocated_trigger_disconnect(
      ::xpilot::TriggerDisconnect* trigger_disconnect);
  ::xpilot::TriggerDisconnect* unsafe_arena_release_trigger_disconnect();

  // .xpilot.PlaneRemovedFromSim plane_removed_from_sim = 22;
  bool has_plane_removed_from_sim() const;
  private:
  bool _internal_has_plane_removed_from_sim() const;
  public:
  void clear_plane_removed_from_sim();
  const ::xpilot::PlaneRemovedFromSim& plane_removed_from_sim() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::PlaneRemovedFromSim* release_plane_removed_from_sim();
  ::xpilot::PlaneRemovedFromSim* mutable_plane_removed_from_sim();
  void set_allocated_plane_removed_from_sim(::xpilot::PlaneRemovedFromSim* plane_removed_from_sim);
  private:
  const ::xpilot::PlaneRemovedFromSim& _internal_plane_removed_from_sim() const;
  ::xpilot::PlaneRemovedFromSim* _internal_mutable_plane_removed_from_sim();
  public:
  void unsafe_arena_set_allocated_plane_removed_from_sim(
      ::xpilot::PlaneRemovedFromSim* plane_removed_from_sim);
  ::xpilot::PlaneRemovedFromSim* unsafe_arena_release_plane_removed_from_sim();

  // .xpilot.ServerMessageReceived server_message_received = 23;
  bool has_server_message_received() const;
  private:
  bool _internal_has_server_message_received() const;
  public:
  void clear_server_message_received();
  const ::xpilot::ServerMessageReceived& server_message_received() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::ServerMessageReceived* release_server_message_received();
  ::xpilot::ServerMessageReceived* mutable_server_message_received();
  void set_allocated_server_message_received(::xpilot::ServerMessageReceived* server_message_received);
  private:
  const ::xpilot::ServerMessageReceived& _internal_server_message_received() const;
  ::xpilot::ServerMessageReceived* _internal_mutable_server_message_received();
  public:
  void unsafe_arena_set_allocated_server_message_received(
      ::xpilot::ServerMessageReceived* server_message_received);
  ::xpilot::ServerMessageReceived* unsafe_arena_release_server_message_received();

  // .xpilot.RequestMetar request_metar = 24;
  bool has_request_metar() const;
  private:
  bool _internal_has_request_metar() const;
  public:
  void clear_request_metar();
  const ::xpilot::RequestMetar& request_metar() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::RequestMetar* release_request_metar();
  ::xpilot::RequestMetar* mutable_request_metar();
  void set_allocated_request_metar(::xpilot::RequestMetar* request_metar);
  private:
  const ::xpilot::RequestMetar& _internal_request_metar() const;
  ::xpilot::RequestMetar* _internal_mutable_request_metar();
  public:
  void unsafe_arena_set_allocated_request_metar(
      ::xpilot::RequestMetar* request_metar);
  ::xpilot::RequestMetar* unsafe_arena_release_request_metar();

  // .xpilot.MetarReceived metar_received = 25;
  bool has_metar_received() const;
  private:
  bool _internal_has_metar_received() const;
  public:
  void clear_metar_received();
  const ::xpilot::MetarReceived& metar_received() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::MetarReceived* release_metar_received();
  ::xpilot::MetarReceived* mutable_metar_received();
  void set_allocated_metar_received(::xpilot::MetarReceived* metar_received);
  private:
  const ::xpilot::MetarReceived& _internal_metar_received() const;
  ::xpilot::MetarReceived* _internal_mutable_metar_received();
  public:
  void unsafe_arena_set_allocated_metar_received(
      ::xpilot::MetarReceived* metar_received);
  ::xpilot::MetarReceived* unsafe_arena_release_metar_received();

  // .xpilot.WallopSent wallop_sent = 26;
  bool has_wallop_sent() const;
  private:
  bool _internal_has_wallop_sent() const;
  public:
  void clear_wallop_sent();
  const ::xpilot::WallopSent& wallop_sent() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::WallopSent* release_wallop_sent();
  ::xpilot::WallopSent* mutable_wallop_sent();
  void set_allocated_wallop_sent(::xpilot::WallopSent* wallop_sent);
  private:
  const ::xpilot::WallopSent& _internal_wallop_sent() const;
  ::xpilot::WallopSent* _internal_mutable_wallop_sent();
  public:
  void unsafe_arena_set_allocated_wallop_sent(
      ::xpilot::WallopSent* wallop_sent);
  ::xpilot::WallopSent* unsafe_arena_release_wallop_sent();

  // .xpilot.BroadcastMessageReceived broadcast_message_received = 27;
  bool has_broadcast_message_received() const;
  private:
  bool _internal_has_broadcast_message_received() const;
  public:
  void clear_broadcast_message_received();
  const ::xpilot::BroadcastMessageReceived& broadcast_message_received() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::BroadcastMessageReceived* release_broadcast_message_received();
  ::xpilot::BroadcastMessageReceived* mutable_broadcast_message_received();
  void set_allocated_broadcast_message_received(::xpilot::BroadcastMessageReceived* broadcast_message_received);
  private:
  const ::xpilot::BroadcastMessageReceived& _internal_broadcast_message_received() const;
  ::xpilot::BroadcastMessageReceived* _internal_mutable_broadcast_message_received();
  public:
  void unsafe_arena_set_allocated_broadcast_message_received(
      ::xpilot::BroadcastMessageReceived* broadcast_message_received);
  ::xpilot::BroadcastMessageReceived* unsafe_arena_release_broadcast_message_received();

  // .xpilot.InfoMessagePosted info_message_posted = 28;
  bool has_info_message_posted() const;
  private:
  bool _internal_has_info_message_posted() const;
  public:
  void clear_info_message_posted();
  const ::xpilot::InfoMessagePosted& info_message_posted() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::InfoMessagePosted* release_info_message_posted();
  ::xpilot::InfoMessagePosted* mutable_info_message_posted();
  void set_allocated_info_message_posted(::xpilot::InfoMessagePosted* info_message_posted);
  private:
  const ::xpilot::InfoMessagePosted& _internal_info_message_posted() const;
  ::xpilot::InfoMessagePosted* _internal_mutable_info_message_posted();
  public:
  void unsafe_arena_set_allocated_info_message_posted(
      ::xpilot::InfoMessagePosted* info_message_posted);
  ::xpilot::InfoMessagePosted* unsafe_arena_release_info_message_posted();

  // .xpilot.NotePosted note_posted = 29;
  bool has_note_posted() const;
  private:
  bool _internal_has_note_posted() const;
  public:
  void clear_note_posted();
  const ::xpilot::NotePosted& note_posted() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::NotePosted* release_note_posted();
  ::xpilot::NotePosted* mutable_note_posted();
  void set_allocated_note_posted(::xpilot::NotePosted* note_posted);
  private:
  const ::xpilot::NotePosted& _internal_note_posted() const;
  ::xpilot::NotePosted* _internal_mutable_note_posted();
  public:
  void unsafe_arena_set_allocated_note_posted(
      ::xpilot::NotePosted* note_posted);
  ::xpilot::NotePosted* unsafe_arena_release_note_posted();

  // .xpilot.SimulatorConnectionState simulator_connection_state = 30;
  bool has_simulator_connection_state() const;
  private:
  bool _internal_has_simulator_connection_state() const;
  public:
  void clear_simulator_connection_state();
  const ::xpilot::SimulatorConnectionState& simulator_connection_state() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::SimulatorConnectionState* release_simulator_connection_state();
  ::xpilot::SimulatorConnectionState* mutable_simulator_connection_state();
  void set_allocated_simulator_connection_state(::xpilot::SimulatorConnectionState* simulator_connection_state);
  private:
  const ::xpilot::SimulatorConnectionState& _internal_simulator_connection_state() const;
  ::xpilot::SimulatorConnectionState* _internal_mutable_simulator_connection_state();
  public:
  void unsafe_arena_set_allocated_simulator_connection_state(
      ::xpilot::SimulatorConnectionState* simulator_connection_state);
  ::xpilot::SimulatorConnectionState* unsafe_arena_release_simulator_connection_state();

  // .xpilot.AppConfig app_config = 31;
  bool has_app_config() const;
  private:
  bool _internal_has_app_config() const;
  public:
  void clear_app_config();
  const ::xpilot::AppConfig& app_config() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::AppConfig* release_app_config();
  ::xpilot::AppConfig* mutable_app_config();
  void set_allocated_app_config(::xpilot::AppConfig* app_config);
  private:
  const ::xpilot::AppConfig& _internal_app_config() const;
  ::xpilot::AppConfig* _internal_mutable_app_config();
  public:
  void unsafe_arena_set_allocated_app_config(
      ::xpilot::AppConfig* app_config);
  ::xpilot::AppConfig* unsafe_arena_release_app_config();

  // .xpilot.RadioStack radio_stack = 32;
  bool has_radio_stack() const;
  private:
  bool _internal_has_radio_stack() const;
  public:
  void clear_radio_stack();
  const ::xpilot::RadioStack& radio_stack() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::xpilot::RadioStack* release_radio_stack();
  ::xpilot::RadioStack* mutable_radio_stack();
  void set_allocated_radio_stack(::xpilot::RadioStack* radio_stack);
  private:
  const ::xpilot::RadioStack& _internal_radio_stack() const;
  ::xpilot::RadioStack* _internal_mutable_radio_stack();
  public:
  void unsafe_arena_set_allocated_radio_stack(
      ::xpilot::RadioStack* radio_stack);
  ::xpilot::RadioStack* unsafe_arena_release_radio_stack();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:xpilot.Envelope)
 private:
  class _Internal;
  void set_has_position_update();
  void set_has_fast_position_update();
  void set_has_airplane_config();
  void set_has_add_plane();
  void set_has_plane_added_to_sim();
  void set_has_change_plane_model();
  void set_has_delete_plane();
  void set_has_private_message_received();
  void set_has_private_message_sent();
  void set_has_text_message_received();
  void set_has_text_message_sent();
  void set_has_network_connected();
  void set_has_network_disconnected();
  void set_has_nearby_controllers();
  void set_has_set_transponder();
  void set_has_set_radiostack();
  void set_has_app_metdata();
  void set_has_csl_validation();
  void set_has_request_controller_info();
  void set_has_trigger_disconnect();
  void set_has_plane_removed_from_sim();
  void set_has_server_message_received();
  void set_has_request_metar();
  void set_has_metar_received();
  void set_has_wallop_sent();
  void set_has_broadcast_message_received();
  void set_has_info_message_posted();
  void set_has_note_posted();
  void set_has_simulator_connection_state();
  void set_has_app_config();
  void set_has_radio_stack();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::xpilot::PositionUpdate* position_update_;
    ::xpilot::FastPositionUpdate* fast_position_update_;
    ::xpilot::AirplaneConfig* airplane_config_;
    ::xpilot::AddPlane* add_plane_;
    ::xpilot::PlaneAddedToSim* plane_added_to_sim_;
    ::xpilot::ChangePlaneModel* change_plane_model_;
    ::xpilot::DeletePlane* delete_plane_;
    ::xpilot::PrivateMessageReceived* private_message_received_;
    ::xpilot::PrivateMessageSent* private_message_sent_;
    ::xpilot::TextMessageReceived* text_message_received_;
    ::xpilot::TextMessageSent* text_message_sent_;
    ::xpilot::NetworkConnected* network_connected_;
    ::xpilot::NetworkDisconnected* network_disconnected_;
    ::xpilot::NearbyControllers* nearby_controllers_;
    ::xpilot::SetTransponder* set_transponder_;
    ::xpilot::SetRadioStack* set_radiostack_;
    ::xpilot::AppMetadata* app_metdata_;
    ::xpilot::CslValidation* csl_validation_;
    ::xpilot::RequestControllerInfo* request_controller_info_;
    ::xpilot::TriggerDisconnect* trigger_disconnect_;
    ::xpilot::PlaneRemovedFromSim* plane_removed_from_sim_;
    ::xpilot::ServerMessageReceived* server_message_received_;
    ::xpilot::RequestMetar* request_metar_;
    ::xpilot::MetarReceived* metar_received_;
    ::xpilot::WallopSent* wallop_sent_;
    ::xpilot::BroadcastMessageReceived* broadcast_message_received_;
    ::xpilot::InfoMessagePosted* info_message_posted_;
    ::xpilot::NotePosted* note_posted_;
    ::xpilot::SimulatorConnectionState* simulator_connection_state_;
    ::xpilot::AppConfig* app_config_;
    ::xpilot::RadioStack* radio_stack_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Envelope_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Envelope

// .google.protobuf.Timestamp timestamp = 1;
inline bool Envelope::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Envelope::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Envelope::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Envelope::timestamp() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.timestamp)
  return _internal_timestamp();
}
inline void Envelope::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Envelope::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Envelope::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Envelope::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Envelope::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.timestamp)
  return _internal_mutable_timestamp();
}
inline void Envelope::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:xpilot.Envelope.timestamp)
}

// .xpilot.PositionUpdate position_update = 2;
inline bool Envelope::_internal_has_position_update() const {
  return event_case() == kPositionUpdate;
}
inline bool Envelope::has_position_update() const {
  return _internal_has_position_update();
}
inline void Envelope::set_has_position_update() {
  _oneof_case_[0] = kPositionUpdate;
}
inline ::xpilot::PositionUpdate* Envelope::release_position_update() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.position_update)
  if (_internal_has_position_update()) {
    clear_has_event();
      ::xpilot::PositionUpdate* temp = event_.position_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.position_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PositionUpdate& Envelope::_internal_position_update() const {
  return _internal_has_position_update()
      ? *event_.position_update_
      : reinterpret_cast< ::xpilot::PositionUpdate&>(::xpilot::_PositionUpdate_default_instance_);
}
inline const ::xpilot::PositionUpdate& Envelope::position_update() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.position_update)
  return _internal_position_update();
}
inline ::xpilot::PositionUpdate* Envelope::unsafe_arena_release_position_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.position_update)
  if (_internal_has_position_update()) {
    clear_has_event();
    ::xpilot::PositionUpdate* temp = event_.position_update_;
    event_.position_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_position_update(::xpilot::PositionUpdate* position_update) {
  clear_event();
  if (position_update) {
    set_has_position_update();
    event_.position_update_ = position_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.position_update)
}
inline ::xpilot::PositionUpdate* Envelope::_internal_mutable_position_update() {
  if (!_internal_has_position_update()) {
    clear_event();
    set_has_position_update();
    event_.position_update_ = CreateMaybeMessage< ::xpilot::PositionUpdate >(GetArenaForAllocation());
  }
  return event_.position_update_;
}
inline ::xpilot::PositionUpdate* Envelope::mutable_position_update() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.position_update)
  return _internal_mutable_position_update();
}

// .xpilot.FastPositionUpdate fast_position_update = 3;
inline bool Envelope::_internal_has_fast_position_update() const {
  return event_case() == kFastPositionUpdate;
}
inline bool Envelope::has_fast_position_update() const {
  return _internal_has_fast_position_update();
}
inline void Envelope::set_has_fast_position_update() {
  _oneof_case_[0] = kFastPositionUpdate;
}
inline ::xpilot::FastPositionUpdate* Envelope::release_fast_position_update() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.fast_position_update)
  if (_internal_has_fast_position_update()) {
    clear_has_event();
      ::xpilot::FastPositionUpdate* temp = event_.fast_position_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.fast_position_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::FastPositionUpdate& Envelope::_internal_fast_position_update() const {
  return _internal_has_fast_position_update()
      ? *event_.fast_position_update_
      : reinterpret_cast< ::xpilot::FastPositionUpdate&>(::xpilot::_FastPositionUpdate_default_instance_);
}
inline const ::xpilot::FastPositionUpdate& Envelope::fast_position_update() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.fast_position_update)
  return _internal_fast_position_update();
}
inline ::xpilot::FastPositionUpdate* Envelope::unsafe_arena_release_fast_position_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.fast_position_update)
  if (_internal_has_fast_position_update()) {
    clear_has_event();
    ::xpilot::FastPositionUpdate* temp = event_.fast_position_update_;
    event_.fast_position_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_fast_position_update(::xpilot::FastPositionUpdate* fast_position_update) {
  clear_event();
  if (fast_position_update) {
    set_has_fast_position_update();
    event_.fast_position_update_ = fast_position_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.fast_position_update)
}
inline ::xpilot::FastPositionUpdate* Envelope::_internal_mutable_fast_position_update() {
  if (!_internal_has_fast_position_update()) {
    clear_event();
    set_has_fast_position_update();
    event_.fast_position_update_ = CreateMaybeMessage< ::xpilot::FastPositionUpdate >(GetArenaForAllocation());
  }
  return event_.fast_position_update_;
}
inline ::xpilot::FastPositionUpdate* Envelope::mutable_fast_position_update() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.fast_position_update)
  return _internal_mutable_fast_position_update();
}

// .xpilot.AirplaneConfig airplane_config = 4;
inline bool Envelope::_internal_has_airplane_config() const {
  return event_case() == kAirplaneConfig;
}
inline bool Envelope::has_airplane_config() const {
  return _internal_has_airplane_config();
}
inline void Envelope::set_has_airplane_config() {
  _oneof_case_[0] = kAirplaneConfig;
}
inline ::xpilot::AirplaneConfig* Envelope::release_airplane_config() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.airplane_config)
  if (_internal_has_airplane_config()) {
    clear_has_event();
      ::xpilot::AirplaneConfig* temp = event_.airplane_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.airplane_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::AirplaneConfig& Envelope::_internal_airplane_config() const {
  return _internal_has_airplane_config()
      ? *event_.airplane_config_
      : reinterpret_cast< ::xpilot::AirplaneConfig&>(::xpilot::_AirplaneConfig_default_instance_);
}
inline const ::xpilot::AirplaneConfig& Envelope::airplane_config() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.airplane_config)
  return _internal_airplane_config();
}
inline ::xpilot::AirplaneConfig* Envelope::unsafe_arena_release_airplane_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.airplane_config)
  if (_internal_has_airplane_config()) {
    clear_has_event();
    ::xpilot::AirplaneConfig* temp = event_.airplane_config_;
    event_.airplane_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_airplane_config(::xpilot::AirplaneConfig* airplane_config) {
  clear_event();
  if (airplane_config) {
    set_has_airplane_config();
    event_.airplane_config_ = airplane_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.airplane_config)
}
inline ::xpilot::AirplaneConfig* Envelope::_internal_mutable_airplane_config() {
  if (!_internal_has_airplane_config()) {
    clear_event();
    set_has_airplane_config();
    event_.airplane_config_ = CreateMaybeMessage< ::xpilot::AirplaneConfig >(GetArenaForAllocation());
  }
  return event_.airplane_config_;
}
inline ::xpilot::AirplaneConfig* Envelope::mutable_airplane_config() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.airplane_config)
  return _internal_mutable_airplane_config();
}

// .xpilot.AddPlane add_plane = 5;
inline bool Envelope::_internal_has_add_plane() const {
  return event_case() == kAddPlane;
}
inline bool Envelope::has_add_plane() const {
  return _internal_has_add_plane();
}
inline void Envelope::set_has_add_plane() {
  _oneof_case_[0] = kAddPlane;
}
inline ::xpilot::AddPlane* Envelope::release_add_plane() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.add_plane)
  if (_internal_has_add_plane()) {
    clear_has_event();
      ::xpilot::AddPlane* temp = event_.add_plane_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.add_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::AddPlane& Envelope::_internal_add_plane() const {
  return _internal_has_add_plane()
      ? *event_.add_plane_
      : reinterpret_cast< ::xpilot::AddPlane&>(::xpilot::_AddPlane_default_instance_);
}
inline const ::xpilot::AddPlane& Envelope::add_plane() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.add_plane)
  return _internal_add_plane();
}
inline ::xpilot::AddPlane* Envelope::unsafe_arena_release_add_plane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.add_plane)
  if (_internal_has_add_plane()) {
    clear_has_event();
    ::xpilot::AddPlane* temp = event_.add_plane_;
    event_.add_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_add_plane(::xpilot::AddPlane* add_plane) {
  clear_event();
  if (add_plane) {
    set_has_add_plane();
    event_.add_plane_ = add_plane;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.add_plane)
}
inline ::xpilot::AddPlane* Envelope::_internal_mutable_add_plane() {
  if (!_internal_has_add_plane()) {
    clear_event();
    set_has_add_plane();
    event_.add_plane_ = CreateMaybeMessage< ::xpilot::AddPlane >(GetArenaForAllocation());
  }
  return event_.add_plane_;
}
inline ::xpilot::AddPlane* Envelope::mutable_add_plane() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.add_plane)
  return _internal_mutable_add_plane();
}

// .xpilot.PlaneAddedToSim plane_added_to_sim = 6;
inline bool Envelope::_internal_has_plane_added_to_sim() const {
  return event_case() == kPlaneAddedToSim;
}
inline bool Envelope::has_plane_added_to_sim() const {
  return _internal_has_plane_added_to_sim();
}
inline void Envelope::set_has_plane_added_to_sim() {
  _oneof_case_[0] = kPlaneAddedToSim;
}
inline ::xpilot::PlaneAddedToSim* Envelope::release_plane_added_to_sim() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.plane_added_to_sim)
  if (_internal_has_plane_added_to_sim()) {
    clear_has_event();
      ::xpilot::PlaneAddedToSim* temp = event_.plane_added_to_sim_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.plane_added_to_sim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PlaneAddedToSim& Envelope::_internal_plane_added_to_sim() const {
  return _internal_has_plane_added_to_sim()
      ? *event_.plane_added_to_sim_
      : reinterpret_cast< ::xpilot::PlaneAddedToSim&>(::xpilot::_PlaneAddedToSim_default_instance_);
}
inline const ::xpilot::PlaneAddedToSim& Envelope::plane_added_to_sim() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.plane_added_to_sim)
  return _internal_plane_added_to_sim();
}
inline ::xpilot::PlaneAddedToSim* Envelope::unsafe_arena_release_plane_added_to_sim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.plane_added_to_sim)
  if (_internal_has_plane_added_to_sim()) {
    clear_has_event();
    ::xpilot::PlaneAddedToSim* temp = event_.plane_added_to_sim_;
    event_.plane_added_to_sim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_plane_added_to_sim(::xpilot::PlaneAddedToSim* plane_added_to_sim) {
  clear_event();
  if (plane_added_to_sim) {
    set_has_plane_added_to_sim();
    event_.plane_added_to_sim_ = plane_added_to_sim;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.plane_added_to_sim)
}
inline ::xpilot::PlaneAddedToSim* Envelope::_internal_mutable_plane_added_to_sim() {
  if (!_internal_has_plane_added_to_sim()) {
    clear_event();
    set_has_plane_added_to_sim();
    event_.plane_added_to_sim_ = CreateMaybeMessage< ::xpilot::PlaneAddedToSim >(GetArenaForAllocation());
  }
  return event_.plane_added_to_sim_;
}
inline ::xpilot::PlaneAddedToSim* Envelope::mutable_plane_added_to_sim() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.plane_added_to_sim)
  return _internal_mutable_plane_added_to_sim();
}

// .xpilot.ChangePlaneModel change_plane_model = 7;
inline bool Envelope::_internal_has_change_plane_model() const {
  return event_case() == kChangePlaneModel;
}
inline bool Envelope::has_change_plane_model() const {
  return _internal_has_change_plane_model();
}
inline void Envelope::set_has_change_plane_model() {
  _oneof_case_[0] = kChangePlaneModel;
}
inline ::xpilot::ChangePlaneModel* Envelope::release_change_plane_model() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.change_plane_model)
  if (_internal_has_change_plane_model()) {
    clear_has_event();
      ::xpilot::ChangePlaneModel* temp = event_.change_plane_model_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.change_plane_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::ChangePlaneModel& Envelope::_internal_change_plane_model() const {
  return _internal_has_change_plane_model()
      ? *event_.change_plane_model_
      : reinterpret_cast< ::xpilot::ChangePlaneModel&>(::xpilot::_ChangePlaneModel_default_instance_);
}
inline const ::xpilot::ChangePlaneModel& Envelope::change_plane_model() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.change_plane_model)
  return _internal_change_plane_model();
}
inline ::xpilot::ChangePlaneModel* Envelope::unsafe_arena_release_change_plane_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.change_plane_model)
  if (_internal_has_change_plane_model()) {
    clear_has_event();
    ::xpilot::ChangePlaneModel* temp = event_.change_plane_model_;
    event_.change_plane_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_change_plane_model(::xpilot::ChangePlaneModel* change_plane_model) {
  clear_event();
  if (change_plane_model) {
    set_has_change_plane_model();
    event_.change_plane_model_ = change_plane_model;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.change_plane_model)
}
inline ::xpilot::ChangePlaneModel* Envelope::_internal_mutable_change_plane_model() {
  if (!_internal_has_change_plane_model()) {
    clear_event();
    set_has_change_plane_model();
    event_.change_plane_model_ = CreateMaybeMessage< ::xpilot::ChangePlaneModel >(GetArenaForAllocation());
  }
  return event_.change_plane_model_;
}
inline ::xpilot::ChangePlaneModel* Envelope::mutable_change_plane_model() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.change_plane_model)
  return _internal_mutable_change_plane_model();
}

// .xpilot.DeletePlane delete_plane = 8;
inline bool Envelope::_internal_has_delete_plane() const {
  return event_case() == kDeletePlane;
}
inline bool Envelope::has_delete_plane() const {
  return _internal_has_delete_plane();
}
inline void Envelope::set_has_delete_plane() {
  _oneof_case_[0] = kDeletePlane;
}
inline ::xpilot::DeletePlane* Envelope::release_delete_plane() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.delete_plane)
  if (_internal_has_delete_plane()) {
    clear_has_event();
      ::xpilot::DeletePlane* temp = event_.delete_plane_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.delete_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::DeletePlane& Envelope::_internal_delete_plane() const {
  return _internal_has_delete_plane()
      ? *event_.delete_plane_
      : reinterpret_cast< ::xpilot::DeletePlane&>(::xpilot::_DeletePlane_default_instance_);
}
inline const ::xpilot::DeletePlane& Envelope::delete_plane() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.delete_plane)
  return _internal_delete_plane();
}
inline ::xpilot::DeletePlane* Envelope::unsafe_arena_release_delete_plane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.delete_plane)
  if (_internal_has_delete_plane()) {
    clear_has_event();
    ::xpilot::DeletePlane* temp = event_.delete_plane_;
    event_.delete_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_delete_plane(::xpilot::DeletePlane* delete_plane) {
  clear_event();
  if (delete_plane) {
    set_has_delete_plane();
    event_.delete_plane_ = delete_plane;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.delete_plane)
}
inline ::xpilot::DeletePlane* Envelope::_internal_mutable_delete_plane() {
  if (!_internal_has_delete_plane()) {
    clear_event();
    set_has_delete_plane();
    event_.delete_plane_ = CreateMaybeMessage< ::xpilot::DeletePlane >(GetArenaForAllocation());
  }
  return event_.delete_plane_;
}
inline ::xpilot::DeletePlane* Envelope::mutable_delete_plane() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.delete_plane)
  return _internal_mutable_delete_plane();
}

// .xpilot.PrivateMessageReceived private_message_received = 9;
inline bool Envelope::_internal_has_private_message_received() const {
  return event_case() == kPrivateMessageReceived;
}
inline bool Envelope::has_private_message_received() const {
  return _internal_has_private_message_received();
}
inline void Envelope::set_has_private_message_received() {
  _oneof_case_[0] = kPrivateMessageReceived;
}
inline ::xpilot::PrivateMessageReceived* Envelope::release_private_message_received() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.private_message_received)
  if (_internal_has_private_message_received()) {
    clear_has_event();
      ::xpilot::PrivateMessageReceived* temp = event_.private_message_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.private_message_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PrivateMessageReceived& Envelope::_internal_private_message_received() const {
  return _internal_has_private_message_received()
      ? *event_.private_message_received_
      : reinterpret_cast< ::xpilot::PrivateMessageReceived&>(::xpilot::_PrivateMessageReceived_default_instance_);
}
inline const ::xpilot::PrivateMessageReceived& Envelope::private_message_received() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.private_message_received)
  return _internal_private_message_received();
}
inline ::xpilot::PrivateMessageReceived* Envelope::unsafe_arena_release_private_message_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.private_message_received)
  if (_internal_has_private_message_received()) {
    clear_has_event();
    ::xpilot::PrivateMessageReceived* temp = event_.private_message_received_;
    event_.private_message_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_private_message_received(::xpilot::PrivateMessageReceived* private_message_received) {
  clear_event();
  if (private_message_received) {
    set_has_private_message_received();
    event_.private_message_received_ = private_message_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.private_message_received)
}
inline ::xpilot::PrivateMessageReceived* Envelope::_internal_mutable_private_message_received() {
  if (!_internal_has_private_message_received()) {
    clear_event();
    set_has_private_message_received();
    event_.private_message_received_ = CreateMaybeMessage< ::xpilot::PrivateMessageReceived >(GetArenaForAllocation());
  }
  return event_.private_message_received_;
}
inline ::xpilot::PrivateMessageReceived* Envelope::mutable_private_message_received() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.private_message_received)
  return _internal_mutable_private_message_received();
}

// .xpilot.PrivateMessageSent private_message_sent = 10;
inline bool Envelope::_internal_has_private_message_sent() const {
  return event_case() == kPrivateMessageSent;
}
inline bool Envelope::has_private_message_sent() const {
  return _internal_has_private_message_sent();
}
inline void Envelope::set_has_private_message_sent() {
  _oneof_case_[0] = kPrivateMessageSent;
}
inline ::xpilot::PrivateMessageSent* Envelope::release_private_message_sent() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.private_message_sent)
  if (_internal_has_private_message_sent()) {
    clear_has_event();
      ::xpilot::PrivateMessageSent* temp = event_.private_message_sent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.private_message_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PrivateMessageSent& Envelope::_internal_private_message_sent() const {
  return _internal_has_private_message_sent()
      ? *event_.private_message_sent_
      : reinterpret_cast< ::xpilot::PrivateMessageSent&>(::xpilot::_PrivateMessageSent_default_instance_);
}
inline const ::xpilot::PrivateMessageSent& Envelope::private_message_sent() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.private_message_sent)
  return _internal_private_message_sent();
}
inline ::xpilot::PrivateMessageSent* Envelope::unsafe_arena_release_private_message_sent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.private_message_sent)
  if (_internal_has_private_message_sent()) {
    clear_has_event();
    ::xpilot::PrivateMessageSent* temp = event_.private_message_sent_;
    event_.private_message_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_private_message_sent(::xpilot::PrivateMessageSent* private_message_sent) {
  clear_event();
  if (private_message_sent) {
    set_has_private_message_sent();
    event_.private_message_sent_ = private_message_sent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.private_message_sent)
}
inline ::xpilot::PrivateMessageSent* Envelope::_internal_mutable_private_message_sent() {
  if (!_internal_has_private_message_sent()) {
    clear_event();
    set_has_private_message_sent();
    event_.private_message_sent_ = CreateMaybeMessage< ::xpilot::PrivateMessageSent >(GetArenaForAllocation());
  }
  return event_.private_message_sent_;
}
inline ::xpilot::PrivateMessageSent* Envelope::mutable_private_message_sent() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.private_message_sent)
  return _internal_mutable_private_message_sent();
}

// .xpilot.TextMessageReceived text_message_received = 11;
inline bool Envelope::_internal_has_text_message_received() const {
  return event_case() == kTextMessageReceived;
}
inline bool Envelope::has_text_message_received() const {
  return _internal_has_text_message_received();
}
inline void Envelope::set_has_text_message_received() {
  _oneof_case_[0] = kTextMessageReceived;
}
inline ::xpilot::TextMessageReceived* Envelope::release_text_message_received() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.text_message_received)
  if (_internal_has_text_message_received()) {
    clear_has_event();
      ::xpilot::TextMessageReceived* temp = event_.text_message_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.text_message_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::TextMessageReceived& Envelope::_internal_text_message_received() const {
  return _internal_has_text_message_received()
      ? *event_.text_message_received_
      : reinterpret_cast< ::xpilot::TextMessageReceived&>(::xpilot::_TextMessageReceived_default_instance_);
}
inline const ::xpilot::TextMessageReceived& Envelope::text_message_received() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.text_message_received)
  return _internal_text_message_received();
}
inline ::xpilot::TextMessageReceived* Envelope::unsafe_arena_release_text_message_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.text_message_received)
  if (_internal_has_text_message_received()) {
    clear_has_event();
    ::xpilot::TextMessageReceived* temp = event_.text_message_received_;
    event_.text_message_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_text_message_received(::xpilot::TextMessageReceived* text_message_received) {
  clear_event();
  if (text_message_received) {
    set_has_text_message_received();
    event_.text_message_received_ = text_message_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.text_message_received)
}
inline ::xpilot::TextMessageReceived* Envelope::_internal_mutable_text_message_received() {
  if (!_internal_has_text_message_received()) {
    clear_event();
    set_has_text_message_received();
    event_.text_message_received_ = CreateMaybeMessage< ::xpilot::TextMessageReceived >(GetArenaForAllocation());
  }
  return event_.text_message_received_;
}
inline ::xpilot::TextMessageReceived* Envelope::mutable_text_message_received() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.text_message_received)
  return _internal_mutable_text_message_received();
}

// .xpilot.TextMessageSent text_message_sent = 12;
inline bool Envelope::_internal_has_text_message_sent() const {
  return event_case() == kTextMessageSent;
}
inline bool Envelope::has_text_message_sent() const {
  return _internal_has_text_message_sent();
}
inline void Envelope::set_has_text_message_sent() {
  _oneof_case_[0] = kTextMessageSent;
}
inline ::xpilot::TextMessageSent* Envelope::release_text_message_sent() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.text_message_sent)
  if (_internal_has_text_message_sent()) {
    clear_has_event();
      ::xpilot::TextMessageSent* temp = event_.text_message_sent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.text_message_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::TextMessageSent& Envelope::_internal_text_message_sent() const {
  return _internal_has_text_message_sent()
      ? *event_.text_message_sent_
      : reinterpret_cast< ::xpilot::TextMessageSent&>(::xpilot::_TextMessageSent_default_instance_);
}
inline const ::xpilot::TextMessageSent& Envelope::text_message_sent() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.text_message_sent)
  return _internal_text_message_sent();
}
inline ::xpilot::TextMessageSent* Envelope::unsafe_arena_release_text_message_sent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.text_message_sent)
  if (_internal_has_text_message_sent()) {
    clear_has_event();
    ::xpilot::TextMessageSent* temp = event_.text_message_sent_;
    event_.text_message_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_text_message_sent(::xpilot::TextMessageSent* text_message_sent) {
  clear_event();
  if (text_message_sent) {
    set_has_text_message_sent();
    event_.text_message_sent_ = text_message_sent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.text_message_sent)
}
inline ::xpilot::TextMessageSent* Envelope::_internal_mutable_text_message_sent() {
  if (!_internal_has_text_message_sent()) {
    clear_event();
    set_has_text_message_sent();
    event_.text_message_sent_ = CreateMaybeMessage< ::xpilot::TextMessageSent >(GetArenaForAllocation());
  }
  return event_.text_message_sent_;
}
inline ::xpilot::TextMessageSent* Envelope::mutable_text_message_sent() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.text_message_sent)
  return _internal_mutable_text_message_sent();
}

// .xpilot.NetworkConnected network_connected = 13;
inline bool Envelope::_internal_has_network_connected() const {
  return event_case() == kNetworkConnected;
}
inline bool Envelope::has_network_connected() const {
  return _internal_has_network_connected();
}
inline void Envelope::set_has_network_connected() {
  _oneof_case_[0] = kNetworkConnected;
}
inline ::xpilot::NetworkConnected* Envelope::release_network_connected() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.network_connected)
  if (_internal_has_network_connected()) {
    clear_has_event();
      ::xpilot::NetworkConnected* temp = event_.network_connected_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.network_connected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::NetworkConnected& Envelope::_internal_network_connected() const {
  return _internal_has_network_connected()
      ? *event_.network_connected_
      : reinterpret_cast< ::xpilot::NetworkConnected&>(::xpilot::_NetworkConnected_default_instance_);
}
inline const ::xpilot::NetworkConnected& Envelope::network_connected() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.network_connected)
  return _internal_network_connected();
}
inline ::xpilot::NetworkConnected* Envelope::unsafe_arena_release_network_connected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.network_connected)
  if (_internal_has_network_connected()) {
    clear_has_event();
    ::xpilot::NetworkConnected* temp = event_.network_connected_;
    event_.network_connected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_network_connected(::xpilot::NetworkConnected* network_connected) {
  clear_event();
  if (network_connected) {
    set_has_network_connected();
    event_.network_connected_ = network_connected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.network_connected)
}
inline ::xpilot::NetworkConnected* Envelope::_internal_mutable_network_connected() {
  if (!_internal_has_network_connected()) {
    clear_event();
    set_has_network_connected();
    event_.network_connected_ = CreateMaybeMessage< ::xpilot::NetworkConnected >(GetArenaForAllocation());
  }
  return event_.network_connected_;
}
inline ::xpilot::NetworkConnected* Envelope::mutable_network_connected() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.network_connected)
  return _internal_mutable_network_connected();
}

// .xpilot.NetworkDisconnected network_disconnected = 14;
inline bool Envelope::_internal_has_network_disconnected() const {
  return event_case() == kNetworkDisconnected;
}
inline bool Envelope::has_network_disconnected() const {
  return _internal_has_network_disconnected();
}
inline void Envelope::set_has_network_disconnected() {
  _oneof_case_[0] = kNetworkDisconnected;
}
inline ::xpilot::NetworkDisconnected* Envelope::release_network_disconnected() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.network_disconnected)
  if (_internal_has_network_disconnected()) {
    clear_has_event();
      ::xpilot::NetworkDisconnected* temp = event_.network_disconnected_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.network_disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::NetworkDisconnected& Envelope::_internal_network_disconnected() const {
  return _internal_has_network_disconnected()
      ? *event_.network_disconnected_
      : reinterpret_cast< ::xpilot::NetworkDisconnected&>(::xpilot::_NetworkDisconnected_default_instance_);
}
inline const ::xpilot::NetworkDisconnected& Envelope::network_disconnected() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.network_disconnected)
  return _internal_network_disconnected();
}
inline ::xpilot::NetworkDisconnected* Envelope::unsafe_arena_release_network_disconnected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.network_disconnected)
  if (_internal_has_network_disconnected()) {
    clear_has_event();
    ::xpilot::NetworkDisconnected* temp = event_.network_disconnected_;
    event_.network_disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_network_disconnected(::xpilot::NetworkDisconnected* network_disconnected) {
  clear_event();
  if (network_disconnected) {
    set_has_network_disconnected();
    event_.network_disconnected_ = network_disconnected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.network_disconnected)
}
inline ::xpilot::NetworkDisconnected* Envelope::_internal_mutable_network_disconnected() {
  if (!_internal_has_network_disconnected()) {
    clear_event();
    set_has_network_disconnected();
    event_.network_disconnected_ = CreateMaybeMessage< ::xpilot::NetworkDisconnected >(GetArenaForAllocation());
  }
  return event_.network_disconnected_;
}
inline ::xpilot::NetworkDisconnected* Envelope::mutable_network_disconnected() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.network_disconnected)
  return _internal_mutable_network_disconnected();
}

// .xpilot.NearbyControllers nearby_controllers = 15;
inline bool Envelope::_internal_has_nearby_controllers() const {
  return event_case() == kNearbyControllers;
}
inline bool Envelope::has_nearby_controllers() const {
  return _internal_has_nearby_controllers();
}
inline void Envelope::set_has_nearby_controllers() {
  _oneof_case_[0] = kNearbyControllers;
}
inline ::xpilot::NearbyControllers* Envelope::release_nearby_controllers() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.nearby_controllers)
  if (_internal_has_nearby_controllers()) {
    clear_has_event();
      ::xpilot::NearbyControllers* temp = event_.nearby_controllers_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.nearby_controllers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::NearbyControllers& Envelope::_internal_nearby_controllers() const {
  return _internal_has_nearby_controllers()
      ? *event_.nearby_controllers_
      : reinterpret_cast< ::xpilot::NearbyControllers&>(::xpilot::_NearbyControllers_default_instance_);
}
inline const ::xpilot::NearbyControllers& Envelope::nearby_controllers() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.nearby_controllers)
  return _internal_nearby_controllers();
}
inline ::xpilot::NearbyControllers* Envelope::unsafe_arena_release_nearby_controllers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.nearby_controllers)
  if (_internal_has_nearby_controllers()) {
    clear_has_event();
    ::xpilot::NearbyControllers* temp = event_.nearby_controllers_;
    event_.nearby_controllers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_nearby_controllers(::xpilot::NearbyControllers* nearby_controllers) {
  clear_event();
  if (nearby_controllers) {
    set_has_nearby_controllers();
    event_.nearby_controllers_ = nearby_controllers;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.nearby_controllers)
}
inline ::xpilot::NearbyControllers* Envelope::_internal_mutable_nearby_controllers() {
  if (!_internal_has_nearby_controllers()) {
    clear_event();
    set_has_nearby_controllers();
    event_.nearby_controllers_ = CreateMaybeMessage< ::xpilot::NearbyControllers >(GetArenaForAllocation());
  }
  return event_.nearby_controllers_;
}
inline ::xpilot::NearbyControllers* Envelope::mutable_nearby_controllers() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.nearby_controllers)
  return _internal_mutable_nearby_controllers();
}

// .xpilot.SetTransponder set_transponder = 16;
inline bool Envelope::_internal_has_set_transponder() const {
  return event_case() == kSetTransponder;
}
inline bool Envelope::has_set_transponder() const {
  return _internal_has_set_transponder();
}
inline void Envelope::set_has_set_transponder() {
  _oneof_case_[0] = kSetTransponder;
}
inline ::xpilot::SetTransponder* Envelope::release_set_transponder() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.set_transponder)
  if (_internal_has_set_transponder()) {
    clear_has_event();
      ::xpilot::SetTransponder* temp = event_.set_transponder_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.set_transponder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::SetTransponder& Envelope::_internal_set_transponder() const {
  return _internal_has_set_transponder()
      ? *event_.set_transponder_
      : reinterpret_cast< ::xpilot::SetTransponder&>(::xpilot::_SetTransponder_default_instance_);
}
inline const ::xpilot::SetTransponder& Envelope::set_transponder() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.set_transponder)
  return _internal_set_transponder();
}
inline ::xpilot::SetTransponder* Envelope::unsafe_arena_release_set_transponder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.set_transponder)
  if (_internal_has_set_transponder()) {
    clear_has_event();
    ::xpilot::SetTransponder* temp = event_.set_transponder_;
    event_.set_transponder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_set_transponder(::xpilot::SetTransponder* set_transponder) {
  clear_event();
  if (set_transponder) {
    set_has_set_transponder();
    event_.set_transponder_ = set_transponder;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.set_transponder)
}
inline ::xpilot::SetTransponder* Envelope::_internal_mutable_set_transponder() {
  if (!_internal_has_set_transponder()) {
    clear_event();
    set_has_set_transponder();
    event_.set_transponder_ = CreateMaybeMessage< ::xpilot::SetTransponder >(GetArenaForAllocation());
  }
  return event_.set_transponder_;
}
inline ::xpilot::SetTransponder* Envelope::mutable_set_transponder() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.set_transponder)
  return _internal_mutable_set_transponder();
}

// .xpilot.SetRadioStack set_radiostack = 17;
inline bool Envelope::_internal_has_set_radiostack() const {
  return event_case() == kSetRadiostack;
}
inline bool Envelope::has_set_radiostack() const {
  return _internal_has_set_radiostack();
}
inline void Envelope::set_has_set_radiostack() {
  _oneof_case_[0] = kSetRadiostack;
}
inline ::xpilot::SetRadioStack* Envelope::release_set_radiostack() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.set_radiostack)
  if (_internal_has_set_radiostack()) {
    clear_has_event();
      ::xpilot::SetRadioStack* temp = event_.set_radiostack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.set_radiostack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::SetRadioStack& Envelope::_internal_set_radiostack() const {
  return _internal_has_set_radiostack()
      ? *event_.set_radiostack_
      : reinterpret_cast< ::xpilot::SetRadioStack&>(::xpilot::_SetRadioStack_default_instance_);
}
inline const ::xpilot::SetRadioStack& Envelope::set_radiostack() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.set_radiostack)
  return _internal_set_radiostack();
}
inline ::xpilot::SetRadioStack* Envelope::unsafe_arena_release_set_radiostack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.set_radiostack)
  if (_internal_has_set_radiostack()) {
    clear_has_event();
    ::xpilot::SetRadioStack* temp = event_.set_radiostack_;
    event_.set_radiostack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_set_radiostack(::xpilot::SetRadioStack* set_radiostack) {
  clear_event();
  if (set_radiostack) {
    set_has_set_radiostack();
    event_.set_radiostack_ = set_radiostack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.set_radiostack)
}
inline ::xpilot::SetRadioStack* Envelope::_internal_mutable_set_radiostack() {
  if (!_internal_has_set_radiostack()) {
    clear_event();
    set_has_set_radiostack();
    event_.set_radiostack_ = CreateMaybeMessage< ::xpilot::SetRadioStack >(GetArenaForAllocation());
  }
  return event_.set_radiostack_;
}
inline ::xpilot::SetRadioStack* Envelope::mutable_set_radiostack() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.set_radiostack)
  return _internal_mutable_set_radiostack();
}

// .xpilot.AppMetadata app_metdata = 18;
inline bool Envelope::_internal_has_app_metdata() const {
  return event_case() == kAppMetdata;
}
inline bool Envelope::has_app_metdata() const {
  return _internal_has_app_metdata();
}
inline void Envelope::set_has_app_metdata() {
  _oneof_case_[0] = kAppMetdata;
}
inline ::xpilot::AppMetadata* Envelope::release_app_metdata() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.app_metdata)
  if (_internal_has_app_metdata()) {
    clear_has_event();
      ::xpilot::AppMetadata* temp = event_.app_metdata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.app_metdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::AppMetadata& Envelope::_internal_app_metdata() const {
  return _internal_has_app_metdata()
      ? *event_.app_metdata_
      : reinterpret_cast< ::xpilot::AppMetadata&>(::xpilot::_AppMetadata_default_instance_);
}
inline const ::xpilot::AppMetadata& Envelope::app_metdata() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.app_metdata)
  return _internal_app_metdata();
}
inline ::xpilot::AppMetadata* Envelope::unsafe_arena_release_app_metdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.app_metdata)
  if (_internal_has_app_metdata()) {
    clear_has_event();
    ::xpilot::AppMetadata* temp = event_.app_metdata_;
    event_.app_metdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_app_metdata(::xpilot::AppMetadata* app_metdata) {
  clear_event();
  if (app_metdata) {
    set_has_app_metdata();
    event_.app_metdata_ = app_metdata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.app_metdata)
}
inline ::xpilot::AppMetadata* Envelope::_internal_mutable_app_metdata() {
  if (!_internal_has_app_metdata()) {
    clear_event();
    set_has_app_metdata();
    event_.app_metdata_ = CreateMaybeMessage< ::xpilot::AppMetadata >(GetArenaForAllocation());
  }
  return event_.app_metdata_;
}
inline ::xpilot::AppMetadata* Envelope::mutable_app_metdata() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.app_metdata)
  return _internal_mutable_app_metdata();
}

// .xpilot.CslValidation csl_validation = 19;
inline bool Envelope::_internal_has_csl_validation() const {
  return event_case() == kCslValidation;
}
inline bool Envelope::has_csl_validation() const {
  return _internal_has_csl_validation();
}
inline void Envelope::set_has_csl_validation() {
  _oneof_case_[0] = kCslValidation;
}
inline ::xpilot::CslValidation* Envelope::release_csl_validation() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.csl_validation)
  if (_internal_has_csl_validation()) {
    clear_has_event();
      ::xpilot::CslValidation* temp = event_.csl_validation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.csl_validation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::CslValidation& Envelope::_internal_csl_validation() const {
  return _internal_has_csl_validation()
      ? *event_.csl_validation_
      : reinterpret_cast< ::xpilot::CslValidation&>(::xpilot::_CslValidation_default_instance_);
}
inline const ::xpilot::CslValidation& Envelope::csl_validation() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.csl_validation)
  return _internal_csl_validation();
}
inline ::xpilot::CslValidation* Envelope::unsafe_arena_release_csl_validation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.csl_validation)
  if (_internal_has_csl_validation()) {
    clear_has_event();
    ::xpilot::CslValidation* temp = event_.csl_validation_;
    event_.csl_validation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_csl_validation(::xpilot::CslValidation* csl_validation) {
  clear_event();
  if (csl_validation) {
    set_has_csl_validation();
    event_.csl_validation_ = csl_validation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.csl_validation)
}
inline ::xpilot::CslValidation* Envelope::_internal_mutable_csl_validation() {
  if (!_internal_has_csl_validation()) {
    clear_event();
    set_has_csl_validation();
    event_.csl_validation_ = CreateMaybeMessage< ::xpilot::CslValidation >(GetArenaForAllocation());
  }
  return event_.csl_validation_;
}
inline ::xpilot::CslValidation* Envelope::mutable_csl_validation() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.csl_validation)
  return _internal_mutable_csl_validation();
}

// .xpilot.RequestControllerInfo request_controller_info = 20;
inline bool Envelope::_internal_has_request_controller_info() const {
  return event_case() == kRequestControllerInfo;
}
inline bool Envelope::has_request_controller_info() const {
  return _internal_has_request_controller_info();
}
inline void Envelope::set_has_request_controller_info() {
  _oneof_case_[0] = kRequestControllerInfo;
}
inline ::xpilot::RequestControllerInfo* Envelope::release_request_controller_info() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.request_controller_info)
  if (_internal_has_request_controller_info()) {
    clear_has_event();
      ::xpilot::RequestControllerInfo* temp = event_.request_controller_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.request_controller_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::RequestControllerInfo& Envelope::_internal_request_controller_info() const {
  return _internal_has_request_controller_info()
      ? *event_.request_controller_info_
      : reinterpret_cast< ::xpilot::RequestControllerInfo&>(::xpilot::_RequestControllerInfo_default_instance_);
}
inline const ::xpilot::RequestControllerInfo& Envelope::request_controller_info() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.request_controller_info)
  return _internal_request_controller_info();
}
inline ::xpilot::RequestControllerInfo* Envelope::unsafe_arena_release_request_controller_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.request_controller_info)
  if (_internal_has_request_controller_info()) {
    clear_has_event();
    ::xpilot::RequestControllerInfo* temp = event_.request_controller_info_;
    event_.request_controller_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_request_controller_info(::xpilot::RequestControllerInfo* request_controller_info) {
  clear_event();
  if (request_controller_info) {
    set_has_request_controller_info();
    event_.request_controller_info_ = request_controller_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.request_controller_info)
}
inline ::xpilot::RequestControllerInfo* Envelope::_internal_mutable_request_controller_info() {
  if (!_internal_has_request_controller_info()) {
    clear_event();
    set_has_request_controller_info();
    event_.request_controller_info_ = CreateMaybeMessage< ::xpilot::RequestControllerInfo >(GetArenaForAllocation());
  }
  return event_.request_controller_info_;
}
inline ::xpilot::RequestControllerInfo* Envelope::mutable_request_controller_info() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.request_controller_info)
  return _internal_mutable_request_controller_info();
}

// .xpilot.TriggerDisconnect trigger_disconnect = 21;
inline bool Envelope::_internal_has_trigger_disconnect() const {
  return event_case() == kTriggerDisconnect;
}
inline bool Envelope::has_trigger_disconnect() const {
  return _internal_has_trigger_disconnect();
}
inline void Envelope::set_has_trigger_disconnect() {
  _oneof_case_[0] = kTriggerDisconnect;
}
inline ::xpilot::TriggerDisconnect* Envelope::release_trigger_disconnect() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.trigger_disconnect)
  if (_internal_has_trigger_disconnect()) {
    clear_has_event();
      ::xpilot::TriggerDisconnect* temp = event_.trigger_disconnect_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.trigger_disconnect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::TriggerDisconnect& Envelope::_internal_trigger_disconnect() const {
  return _internal_has_trigger_disconnect()
      ? *event_.trigger_disconnect_
      : reinterpret_cast< ::xpilot::TriggerDisconnect&>(::xpilot::_TriggerDisconnect_default_instance_);
}
inline const ::xpilot::TriggerDisconnect& Envelope::trigger_disconnect() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.trigger_disconnect)
  return _internal_trigger_disconnect();
}
inline ::xpilot::TriggerDisconnect* Envelope::unsafe_arena_release_trigger_disconnect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.trigger_disconnect)
  if (_internal_has_trigger_disconnect()) {
    clear_has_event();
    ::xpilot::TriggerDisconnect* temp = event_.trigger_disconnect_;
    event_.trigger_disconnect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_trigger_disconnect(::xpilot::TriggerDisconnect* trigger_disconnect) {
  clear_event();
  if (trigger_disconnect) {
    set_has_trigger_disconnect();
    event_.trigger_disconnect_ = trigger_disconnect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.trigger_disconnect)
}
inline ::xpilot::TriggerDisconnect* Envelope::_internal_mutable_trigger_disconnect() {
  if (!_internal_has_trigger_disconnect()) {
    clear_event();
    set_has_trigger_disconnect();
    event_.trigger_disconnect_ = CreateMaybeMessage< ::xpilot::TriggerDisconnect >(GetArenaForAllocation());
  }
  return event_.trigger_disconnect_;
}
inline ::xpilot::TriggerDisconnect* Envelope::mutable_trigger_disconnect() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.trigger_disconnect)
  return _internal_mutable_trigger_disconnect();
}

// .xpilot.PlaneRemovedFromSim plane_removed_from_sim = 22;
inline bool Envelope::_internal_has_plane_removed_from_sim() const {
  return event_case() == kPlaneRemovedFromSim;
}
inline bool Envelope::has_plane_removed_from_sim() const {
  return _internal_has_plane_removed_from_sim();
}
inline void Envelope::set_has_plane_removed_from_sim() {
  _oneof_case_[0] = kPlaneRemovedFromSim;
}
inline ::xpilot::PlaneRemovedFromSim* Envelope::release_plane_removed_from_sim() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.plane_removed_from_sim)
  if (_internal_has_plane_removed_from_sim()) {
    clear_has_event();
      ::xpilot::PlaneRemovedFromSim* temp = event_.plane_removed_from_sim_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.plane_removed_from_sim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PlaneRemovedFromSim& Envelope::_internal_plane_removed_from_sim() const {
  return _internal_has_plane_removed_from_sim()
      ? *event_.plane_removed_from_sim_
      : reinterpret_cast< ::xpilot::PlaneRemovedFromSim&>(::xpilot::_PlaneRemovedFromSim_default_instance_);
}
inline const ::xpilot::PlaneRemovedFromSim& Envelope::plane_removed_from_sim() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.plane_removed_from_sim)
  return _internal_plane_removed_from_sim();
}
inline ::xpilot::PlaneRemovedFromSim* Envelope::unsafe_arena_release_plane_removed_from_sim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.plane_removed_from_sim)
  if (_internal_has_plane_removed_from_sim()) {
    clear_has_event();
    ::xpilot::PlaneRemovedFromSim* temp = event_.plane_removed_from_sim_;
    event_.plane_removed_from_sim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_plane_removed_from_sim(::xpilot::PlaneRemovedFromSim* plane_removed_from_sim) {
  clear_event();
  if (plane_removed_from_sim) {
    set_has_plane_removed_from_sim();
    event_.plane_removed_from_sim_ = plane_removed_from_sim;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.plane_removed_from_sim)
}
inline ::xpilot::PlaneRemovedFromSim* Envelope::_internal_mutable_plane_removed_from_sim() {
  if (!_internal_has_plane_removed_from_sim()) {
    clear_event();
    set_has_plane_removed_from_sim();
    event_.plane_removed_from_sim_ = CreateMaybeMessage< ::xpilot::PlaneRemovedFromSim >(GetArenaForAllocation());
  }
  return event_.plane_removed_from_sim_;
}
inline ::xpilot::PlaneRemovedFromSim* Envelope::mutable_plane_removed_from_sim() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.plane_removed_from_sim)
  return _internal_mutable_plane_removed_from_sim();
}

// .xpilot.ServerMessageReceived server_message_received = 23;
inline bool Envelope::_internal_has_server_message_received() const {
  return event_case() == kServerMessageReceived;
}
inline bool Envelope::has_server_message_received() const {
  return _internal_has_server_message_received();
}
inline void Envelope::set_has_server_message_received() {
  _oneof_case_[0] = kServerMessageReceived;
}
inline ::xpilot::ServerMessageReceived* Envelope::release_server_message_received() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.server_message_received)
  if (_internal_has_server_message_received()) {
    clear_has_event();
      ::xpilot::ServerMessageReceived* temp = event_.server_message_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.server_message_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::ServerMessageReceived& Envelope::_internal_server_message_received() const {
  return _internal_has_server_message_received()
      ? *event_.server_message_received_
      : reinterpret_cast< ::xpilot::ServerMessageReceived&>(::xpilot::_ServerMessageReceived_default_instance_);
}
inline const ::xpilot::ServerMessageReceived& Envelope::server_message_received() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.server_message_received)
  return _internal_server_message_received();
}
inline ::xpilot::ServerMessageReceived* Envelope::unsafe_arena_release_server_message_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.server_message_received)
  if (_internal_has_server_message_received()) {
    clear_has_event();
    ::xpilot::ServerMessageReceived* temp = event_.server_message_received_;
    event_.server_message_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_server_message_received(::xpilot::ServerMessageReceived* server_message_received) {
  clear_event();
  if (server_message_received) {
    set_has_server_message_received();
    event_.server_message_received_ = server_message_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.server_message_received)
}
inline ::xpilot::ServerMessageReceived* Envelope::_internal_mutable_server_message_received() {
  if (!_internal_has_server_message_received()) {
    clear_event();
    set_has_server_message_received();
    event_.server_message_received_ = CreateMaybeMessage< ::xpilot::ServerMessageReceived >(GetArenaForAllocation());
  }
  return event_.server_message_received_;
}
inline ::xpilot::ServerMessageReceived* Envelope::mutable_server_message_received() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.server_message_received)
  return _internal_mutable_server_message_received();
}

// .xpilot.RequestMetar request_metar = 24;
inline bool Envelope::_internal_has_request_metar() const {
  return event_case() == kRequestMetar;
}
inline bool Envelope::has_request_metar() const {
  return _internal_has_request_metar();
}
inline void Envelope::set_has_request_metar() {
  _oneof_case_[0] = kRequestMetar;
}
inline ::xpilot::RequestMetar* Envelope::release_request_metar() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.request_metar)
  if (_internal_has_request_metar()) {
    clear_has_event();
      ::xpilot::RequestMetar* temp = event_.request_metar_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.request_metar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::RequestMetar& Envelope::_internal_request_metar() const {
  return _internal_has_request_metar()
      ? *event_.request_metar_
      : reinterpret_cast< ::xpilot::RequestMetar&>(::xpilot::_RequestMetar_default_instance_);
}
inline const ::xpilot::RequestMetar& Envelope::request_metar() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.request_metar)
  return _internal_request_metar();
}
inline ::xpilot::RequestMetar* Envelope::unsafe_arena_release_request_metar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.request_metar)
  if (_internal_has_request_metar()) {
    clear_has_event();
    ::xpilot::RequestMetar* temp = event_.request_metar_;
    event_.request_metar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_request_metar(::xpilot::RequestMetar* request_metar) {
  clear_event();
  if (request_metar) {
    set_has_request_metar();
    event_.request_metar_ = request_metar;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.request_metar)
}
inline ::xpilot::RequestMetar* Envelope::_internal_mutable_request_metar() {
  if (!_internal_has_request_metar()) {
    clear_event();
    set_has_request_metar();
    event_.request_metar_ = CreateMaybeMessage< ::xpilot::RequestMetar >(GetArenaForAllocation());
  }
  return event_.request_metar_;
}
inline ::xpilot::RequestMetar* Envelope::mutable_request_metar() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.request_metar)
  return _internal_mutable_request_metar();
}

// .xpilot.MetarReceived metar_received = 25;
inline bool Envelope::_internal_has_metar_received() const {
  return event_case() == kMetarReceived;
}
inline bool Envelope::has_metar_received() const {
  return _internal_has_metar_received();
}
inline void Envelope::set_has_metar_received() {
  _oneof_case_[0] = kMetarReceived;
}
inline ::xpilot::MetarReceived* Envelope::release_metar_received() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.metar_received)
  if (_internal_has_metar_received()) {
    clear_has_event();
      ::xpilot::MetarReceived* temp = event_.metar_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.metar_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::MetarReceived& Envelope::_internal_metar_received() const {
  return _internal_has_metar_received()
      ? *event_.metar_received_
      : reinterpret_cast< ::xpilot::MetarReceived&>(::xpilot::_MetarReceived_default_instance_);
}
inline const ::xpilot::MetarReceived& Envelope::metar_received() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.metar_received)
  return _internal_metar_received();
}
inline ::xpilot::MetarReceived* Envelope::unsafe_arena_release_metar_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.metar_received)
  if (_internal_has_metar_received()) {
    clear_has_event();
    ::xpilot::MetarReceived* temp = event_.metar_received_;
    event_.metar_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_metar_received(::xpilot::MetarReceived* metar_received) {
  clear_event();
  if (metar_received) {
    set_has_metar_received();
    event_.metar_received_ = metar_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.metar_received)
}
inline ::xpilot::MetarReceived* Envelope::_internal_mutable_metar_received() {
  if (!_internal_has_metar_received()) {
    clear_event();
    set_has_metar_received();
    event_.metar_received_ = CreateMaybeMessage< ::xpilot::MetarReceived >(GetArenaForAllocation());
  }
  return event_.metar_received_;
}
inline ::xpilot::MetarReceived* Envelope::mutable_metar_received() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.metar_received)
  return _internal_mutable_metar_received();
}

// .xpilot.WallopSent wallop_sent = 26;
inline bool Envelope::_internal_has_wallop_sent() const {
  return event_case() == kWallopSent;
}
inline bool Envelope::has_wallop_sent() const {
  return _internal_has_wallop_sent();
}
inline void Envelope::set_has_wallop_sent() {
  _oneof_case_[0] = kWallopSent;
}
inline ::xpilot::WallopSent* Envelope::release_wallop_sent() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.wallop_sent)
  if (_internal_has_wallop_sent()) {
    clear_has_event();
      ::xpilot::WallopSent* temp = event_.wallop_sent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.wallop_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::WallopSent& Envelope::_internal_wallop_sent() const {
  return _internal_has_wallop_sent()
      ? *event_.wallop_sent_
      : reinterpret_cast< ::xpilot::WallopSent&>(::xpilot::_WallopSent_default_instance_);
}
inline const ::xpilot::WallopSent& Envelope::wallop_sent() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.wallop_sent)
  return _internal_wallop_sent();
}
inline ::xpilot::WallopSent* Envelope::unsafe_arena_release_wallop_sent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.wallop_sent)
  if (_internal_has_wallop_sent()) {
    clear_has_event();
    ::xpilot::WallopSent* temp = event_.wallop_sent_;
    event_.wallop_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_wallop_sent(::xpilot::WallopSent* wallop_sent) {
  clear_event();
  if (wallop_sent) {
    set_has_wallop_sent();
    event_.wallop_sent_ = wallop_sent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.wallop_sent)
}
inline ::xpilot::WallopSent* Envelope::_internal_mutable_wallop_sent() {
  if (!_internal_has_wallop_sent()) {
    clear_event();
    set_has_wallop_sent();
    event_.wallop_sent_ = CreateMaybeMessage< ::xpilot::WallopSent >(GetArenaForAllocation());
  }
  return event_.wallop_sent_;
}
inline ::xpilot::WallopSent* Envelope::mutable_wallop_sent() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.wallop_sent)
  return _internal_mutable_wallop_sent();
}

// .xpilot.BroadcastMessageReceived broadcast_message_received = 27;
inline bool Envelope::_internal_has_broadcast_message_received() const {
  return event_case() == kBroadcastMessageReceived;
}
inline bool Envelope::has_broadcast_message_received() const {
  return _internal_has_broadcast_message_received();
}
inline void Envelope::set_has_broadcast_message_received() {
  _oneof_case_[0] = kBroadcastMessageReceived;
}
inline ::xpilot::BroadcastMessageReceived* Envelope::release_broadcast_message_received() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.broadcast_message_received)
  if (_internal_has_broadcast_message_received()) {
    clear_has_event();
      ::xpilot::BroadcastMessageReceived* temp = event_.broadcast_message_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.broadcast_message_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::BroadcastMessageReceived& Envelope::_internal_broadcast_message_received() const {
  return _internal_has_broadcast_message_received()
      ? *event_.broadcast_message_received_
      : reinterpret_cast< ::xpilot::BroadcastMessageReceived&>(::xpilot::_BroadcastMessageReceived_default_instance_);
}
inline const ::xpilot::BroadcastMessageReceived& Envelope::broadcast_message_received() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.broadcast_message_received)
  return _internal_broadcast_message_received();
}
inline ::xpilot::BroadcastMessageReceived* Envelope::unsafe_arena_release_broadcast_message_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.broadcast_message_received)
  if (_internal_has_broadcast_message_received()) {
    clear_has_event();
    ::xpilot::BroadcastMessageReceived* temp = event_.broadcast_message_received_;
    event_.broadcast_message_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_broadcast_message_received(::xpilot::BroadcastMessageReceived* broadcast_message_received) {
  clear_event();
  if (broadcast_message_received) {
    set_has_broadcast_message_received();
    event_.broadcast_message_received_ = broadcast_message_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.broadcast_message_received)
}
inline ::xpilot::BroadcastMessageReceived* Envelope::_internal_mutable_broadcast_message_received() {
  if (!_internal_has_broadcast_message_received()) {
    clear_event();
    set_has_broadcast_message_received();
    event_.broadcast_message_received_ = CreateMaybeMessage< ::xpilot::BroadcastMessageReceived >(GetArenaForAllocation());
  }
  return event_.broadcast_message_received_;
}
inline ::xpilot::BroadcastMessageReceived* Envelope::mutable_broadcast_message_received() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.broadcast_message_received)
  return _internal_mutable_broadcast_message_received();
}

// .xpilot.InfoMessagePosted info_message_posted = 28;
inline bool Envelope::_internal_has_info_message_posted() const {
  return event_case() == kInfoMessagePosted;
}
inline bool Envelope::has_info_message_posted() const {
  return _internal_has_info_message_posted();
}
inline void Envelope::set_has_info_message_posted() {
  _oneof_case_[0] = kInfoMessagePosted;
}
inline ::xpilot::InfoMessagePosted* Envelope::release_info_message_posted() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.info_message_posted)
  if (_internal_has_info_message_posted()) {
    clear_has_event();
      ::xpilot::InfoMessagePosted* temp = event_.info_message_posted_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.info_message_posted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::InfoMessagePosted& Envelope::_internal_info_message_posted() const {
  return _internal_has_info_message_posted()
      ? *event_.info_message_posted_
      : reinterpret_cast< ::xpilot::InfoMessagePosted&>(::xpilot::_InfoMessagePosted_default_instance_);
}
inline const ::xpilot::InfoMessagePosted& Envelope::info_message_posted() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.info_message_posted)
  return _internal_info_message_posted();
}
inline ::xpilot::InfoMessagePosted* Envelope::unsafe_arena_release_info_message_posted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.info_message_posted)
  if (_internal_has_info_message_posted()) {
    clear_has_event();
    ::xpilot::InfoMessagePosted* temp = event_.info_message_posted_;
    event_.info_message_posted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_info_message_posted(::xpilot::InfoMessagePosted* info_message_posted) {
  clear_event();
  if (info_message_posted) {
    set_has_info_message_posted();
    event_.info_message_posted_ = info_message_posted;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.info_message_posted)
}
inline ::xpilot::InfoMessagePosted* Envelope::_internal_mutable_info_message_posted() {
  if (!_internal_has_info_message_posted()) {
    clear_event();
    set_has_info_message_posted();
    event_.info_message_posted_ = CreateMaybeMessage< ::xpilot::InfoMessagePosted >(GetArenaForAllocation());
  }
  return event_.info_message_posted_;
}
inline ::xpilot::InfoMessagePosted* Envelope::mutable_info_message_posted() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.info_message_posted)
  return _internal_mutable_info_message_posted();
}

// .xpilot.NotePosted note_posted = 29;
inline bool Envelope::_internal_has_note_posted() const {
  return event_case() == kNotePosted;
}
inline bool Envelope::has_note_posted() const {
  return _internal_has_note_posted();
}
inline void Envelope::set_has_note_posted() {
  _oneof_case_[0] = kNotePosted;
}
inline ::xpilot::NotePosted* Envelope::release_note_posted() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.note_posted)
  if (_internal_has_note_posted()) {
    clear_has_event();
      ::xpilot::NotePosted* temp = event_.note_posted_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.note_posted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::NotePosted& Envelope::_internal_note_posted() const {
  return _internal_has_note_posted()
      ? *event_.note_posted_
      : reinterpret_cast< ::xpilot::NotePosted&>(::xpilot::_NotePosted_default_instance_);
}
inline const ::xpilot::NotePosted& Envelope::note_posted() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.note_posted)
  return _internal_note_posted();
}
inline ::xpilot::NotePosted* Envelope::unsafe_arena_release_note_posted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.note_posted)
  if (_internal_has_note_posted()) {
    clear_has_event();
    ::xpilot::NotePosted* temp = event_.note_posted_;
    event_.note_posted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_note_posted(::xpilot::NotePosted* note_posted) {
  clear_event();
  if (note_posted) {
    set_has_note_posted();
    event_.note_posted_ = note_posted;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.note_posted)
}
inline ::xpilot::NotePosted* Envelope::_internal_mutable_note_posted() {
  if (!_internal_has_note_posted()) {
    clear_event();
    set_has_note_posted();
    event_.note_posted_ = CreateMaybeMessage< ::xpilot::NotePosted >(GetArenaForAllocation());
  }
  return event_.note_posted_;
}
inline ::xpilot::NotePosted* Envelope::mutable_note_posted() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.note_posted)
  return _internal_mutable_note_posted();
}

// .xpilot.SimulatorConnectionState simulator_connection_state = 30;
inline bool Envelope::_internal_has_simulator_connection_state() const {
  return event_case() == kSimulatorConnectionState;
}
inline bool Envelope::has_simulator_connection_state() const {
  return _internal_has_simulator_connection_state();
}
inline void Envelope::set_has_simulator_connection_state() {
  _oneof_case_[0] = kSimulatorConnectionState;
}
inline ::xpilot::SimulatorConnectionState* Envelope::release_simulator_connection_state() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.simulator_connection_state)
  if (_internal_has_simulator_connection_state()) {
    clear_has_event();
      ::xpilot::SimulatorConnectionState* temp = event_.simulator_connection_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.simulator_connection_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::SimulatorConnectionState& Envelope::_internal_simulator_connection_state() const {
  return _internal_has_simulator_connection_state()
      ? *event_.simulator_connection_state_
      : reinterpret_cast< ::xpilot::SimulatorConnectionState&>(::xpilot::_SimulatorConnectionState_default_instance_);
}
inline const ::xpilot::SimulatorConnectionState& Envelope::simulator_connection_state() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.simulator_connection_state)
  return _internal_simulator_connection_state();
}
inline ::xpilot::SimulatorConnectionState* Envelope::unsafe_arena_release_simulator_connection_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.simulator_connection_state)
  if (_internal_has_simulator_connection_state()) {
    clear_has_event();
    ::xpilot::SimulatorConnectionState* temp = event_.simulator_connection_state_;
    event_.simulator_connection_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_simulator_connection_state(::xpilot::SimulatorConnectionState* simulator_connection_state) {
  clear_event();
  if (simulator_connection_state) {
    set_has_simulator_connection_state();
    event_.simulator_connection_state_ = simulator_connection_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.simulator_connection_state)
}
inline ::xpilot::SimulatorConnectionState* Envelope::_internal_mutable_simulator_connection_state() {
  if (!_internal_has_simulator_connection_state()) {
    clear_event();
    set_has_simulator_connection_state();
    event_.simulator_connection_state_ = CreateMaybeMessage< ::xpilot::SimulatorConnectionState >(GetArenaForAllocation());
  }
  return event_.simulator_connection_state_;
}
inline ::xpilot::SimulatorConnectionState* Envelope::mutable_simulator_connection_state() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.simulator_connection_state)
  return _internal_mutable_simulator_connection_state();
}

// .xpilot.AppConfig app_config = 31;
inline bool Envelope::_internal_has_app_config() const {
  return event_case() == kAppConfig;
}
inline bool Envelope::has_app_config() const {
  return _internal_has_app_config();
}
inline void Envelope::set_has_app_config() {
  _oneof_case_[0] = kAppConfig;
}
inline ::xpilot::AppConfig* Envelope::release_app_config() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.app_config)
  if (_internal_has_app_config()) {
    clear_has_event();
      ::xpilot::AppConfig* temp = event_.app_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.app_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::AppConfig& Envelope::_internal_app_config() const {
  return _internal_has_app_config()
      ? *event_.app_config_
      : reinterpret_cast< ::xpilot::AppConfig&>(::xpilot::_AppConfig_default_instance_);
}
inline const ::xpilot::AppConfig& Envelope::app_config() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.app_config)
  return _internal_app_config();
}
inline ::xpilot::AppConfig* Envelope::unsafe_arena_release_app_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.app_config)
  if (_internal_has_app_config()) {
    clear_has_event();
    ::xpilot::AppConfig* temp = event_.app_config_;
    event_.app_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_app_config(::xpilot::AppConfig* app_config) {
  clear_event();
  if (app_config) {
    set_has_app_config();
    event_.app_config_ = app_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.app_config)
}
inline ::xpilot::AppConfig* Envelope::_internal_mutable_app_config() {
  if (!_internal_has_app_config()) {
    clear_event();
    set_has_app_config();
    event_.app_config_ = CreateMaybeMessage< ::xpilot::AppConfig >(GetArenaForAllocation());
  }
  return event_.app_config_;
}
inline ::xpilot::AppConfig* Envelope::mutable_app_config() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.app_config)
  return _internal_mutable_app_config();
}

// .xpilot.RadioStack radio_stack = 32;
inline bool Envelope::_internal_has_radio_stack() const {
  return event_case() == kRadioStack;
}
inline bool Envelope::has_radio_stack() const {
  return _internal_has_radio_stack();
}
inline void Envelope::set_has_radio_stack() {
  _oneof_case_[0] = kRadioStack;
}
inline ::xpilot::RadioStack* Envelope::release_radio_stack() {
  // @@protoc_insertion_point(field_release:xpilot.Envelope.radio_stack)
  if (_internal_has_radio_stack()) {
    clear_has_event();
      ::xpilot::RadioStack* temp = event_.radio_stack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.radio_stack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::RadioStack& Envelope::_internal_radio_stack() const {
  return _internal_has_radio_stack()
      ? *event_.radio_stack_
      : reinterpret_cast< ::xpilot::RadioStack&>(::xpilot::_RadioStack_default_instance_);
}
inline const ::xpilot::RadioStack& Envelope::radio_stack() const {
  // @@protoc_insertion_point(field_get:xpilot.Envelope.radio_stack)
  return _internal_radio_stack();
}
inline ::xpilot::RadioStack* Envelope::unsafe_arena_release_radio_stack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Envelope.radio_stack)
  if (_internal_has_radio_stack()) {
    clear_has_event();
    ::xpilot::RadioStack* temp = event_.radio_stack_;
    event_.radio_stack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_radio_stack(::xpilot::RadioStack* radio_stack) {
  clear_event();
  if (radio_stack) {
    set_has_radio_stack();
    event_.radio_stack_ = radio_stack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Envelope.radio_stack)
}
inline ::xpilot::RadioStack* Envelope::_internal_mutable_radio_stack() {
  if (!_internal_has_radio_stack()) {
    clear_event();
    set_has_radio_stack();
    event_.radio_stack_ = CreateMaybeMessage< ::xpilot::RadioStack >(GetArenaForAllocation());
  }
  return event_.radio_stack_;
}
inline ::xpilot::RadioStack* Envelope::mutable_radio_stack() {
  // @@protoc_insertion_point(field_mutable:xpilot.Envelope.radio_stack)
  return _internal_mutable_radio_stack();
}

inline bool Envelope::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void Envelope::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline Envelope::EventCase Envelope::event_case() const {
  return Envelope::EventCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace xpilot

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Envelope_2eproto
