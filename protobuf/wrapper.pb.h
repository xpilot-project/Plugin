// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wrapper.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_wrapper_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_wrapper_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "xplanedata.pb.h"
#include "pluginhash.pb.h"
#include "pluginversion.pb.h"
#include "cslvalidate.pb.h"
#include "addplane.pb.h"
#include "changemodel.pb.h"
#include "positionupdate.pb.h"
#include "removeplane.pb.h"
#include "removeallplanes.pb.h"
#include "networkconnected.pb.h"
#include "networkdisconnected.pb.h"
#include "airplaneconfig.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_wrapper_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_wrapper_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_wrapper_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_wrapper_2eproto_metadata_getter(int index);
namespace xpilot {
class Wrapper;
struct WrapperDefaultTypeInternal;
extern WrapperDefaultTypeInternal _Wrapper_default_instance_;
}  // namespace xpilot
PROTOBUF_NAMESPACE_OPEN
template<> ::xpilot::Wrapper* Arena::CreateMaybeMessage<::xpilot::Wrapper>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace xpilot {

// ===================================================================

class Wrapper PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xpilot.Wrapper) */ {
 public:
  inline Wrapper() : Wrapper(nullptr) {}
  virtual ~Wrapper();
  explicit constexpr Wrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wrapper(const Wrapper& from);
  Wrapper(Wrapper&& from) noexcept
    : Wrapper() {
    *this = ::std::move(from);
  }

  inline Wrapper& operator=(const Wrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wrapper& operator=(Wrapper&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Wrapper& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kXplaneData = 2,
    kPluginHash = 3,
    kPluginVersion = 4,
    kCslValidate = 5,
    kAddPlane = 6,
    kChangeModel = 7,
    kPositionUpdate = 8,
    kRemovePlane = 9,
    kRemoveAllPlanes = 10,
    kNetworkConnected = 11,
    kNetworkDisconnected = 12,
    kAirplaneConfig = 13,
    MSG_NOT_SET = 0,
  };

  static inline const Wrapper* internal_default_instance() {
    return reinterpret_cast<const Wrapper*>(
               &_Wrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Wrapper& a, Wrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(Wrapper* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Wrapper* New() const final {
    return CreateMaybeMessage<Wrapper>(nullptr);
  }

  Wrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Wrapper>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Wrapper& from);
  void MergeFrom(const Wrapper& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wrapper* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xpilot.Wrapper";
  }
  protected:
  explicit Wrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_wrapper_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kXplaneDataFieldNumber = 2,
    kPluginHashFieldNumber = 3,
    kPluginVersionFieldNumber = 4,
    kCslValidateFieldNumber = 5,
    kAddPlaneFieldNumber = 6,
    kChangeModelFieldNumber = 7,
    kPositionUpdateFieldNumber = 8,
    kRemovePlaneFieldNumber = 9,
    kRemoveAllPlanesFieldNumber = 10,
    kNetworkConnectedFieldNumber = 11,
    kNetworkDisconnectedFieldNumber = 12,
    kAirplaneConfigFieldNumber = 13,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .xpilot.XplaneData xplane_data = 2;
  bool has_xplane_data() const;
  private:
  bool _internal_has_xplane_data() const;
  public:
  void clear_xplane_data();
  const ::xpilot::XplaneData& xplane_data() const;
  ::xpilot::XplaneData* release_xplane_data();
  ::xpilot::XplaneData* mutable_xplane_data();
  void set_allocated_xplane_data(::xpilot::XplaneData* xplane_data);
  private:
  const ::xpilot::XplaneData& _internal_xplane_data() const;
  ::xpilot::XplaneData* _internal_mutable_xplane_data();
  public:
  void unsafe_arena_set_allocated_xplane_data(
      ::xpilot::XplaneData* xplane_data);
  ::xpilot::XplaneData* unsafe_arena_release_xplane_data();

  // .xpilot.PluginHash plugin_hash = 3;
  bool has_plugin_hash() const;
  private:
  bool _internal_has_plugin_hash() const;
  public:
  void clear_plugin_hash();
  const ::xpilot::PluginHash& plugin_hash() const;
  ::xpilot::PluginHash* release_plugin_hash();
  ::xpilot::PluginHash* mutable_plugin_hash();
  void set_allocated_plugin_hash(::xpilot::PluginHash* plugin_hash);
  private:
  const ::xpilot::PluginHash& _internal_plugin_hash() const;
  ::xpilot::PluginHash* _internal_mutable_plugin_hash();
  public:
  void unsafe_arena_set_allocated_plugin_hash(
      ::xpilot::PluginHash* plugin_hash);
  ::xpilot::PluginHash* unsafe_arena_release_plugin_hash();

  // .xpilot.PluginVersion plugin_version = 4;
  bool has_plugin_version() const;
  private:
  bool _internal_has_plugin_version() const;
  public:
  void clear_plugin_version();
  const ::xpilot::PluginVersion& plugin_version() const;
  ::xpilot::PluginVersion* release_plugin_version();
  ::xpilot::PluginVersion* mutable_plugin_version();
  void set_allocated_plugin_version(::xpilot::PluginVersion* plugin_version);
  private:
  const ::xpilot::PluginVersion& _internal_plugin_version() const;
  ::xpilot::PluginVersion* _internal_mutable_plugin_version();
  public:
  void unsafe_arena_set_allocated_plugin_version(
      ::xpilot::PluginVersion* plugin_version);
  ::xpilot::PluginVersion* unsafe_arena_release_plugin_version();

  // .xpilot.CslValidate csl_validate = 5;
  bool has_csl_validate() const;
  private:
  bool _internal_has_csl_validate() const;
  public:
  void clear_csl_validate();
  const ::xpilot::CslValidate& csl_validate() const;
  ::xpilot::CslValidate* release_csl_validate();
  ::xpilot::CslValidate* mutable_csl_validate();
  void set_allocated_csl_validate(::xpilot::CslValidate* csl_validate);
  private:
  const ::xpilot::CslValidate& _internal_csl_validate() const;
  ::xpilot::CslValidate* _internal_mutable_csl_validate();
  public:
  void unsafe_arena_set_allocated_csl_validate(
      ::xpilot::CslValidate* csl_validate);
  ::xpilot::CslValidate* unsafe_arena_release_csl_validate();

  // .xpilot.AddPlane add_plane = 6;
  bool has_add_plane() const;
  private:
  bool _internal_has_add_plane() const;
  public:
  void clear_add_plane();
  const ::xpilot::AddPlane& add_plane() const;
  ::xpilot::AddPlane* release_add_plane();
  ::xpilot::AddPlane* mutable_add_plane();
  void set_allocated_add_plane(::xpilot::AddPlane* add_plane);
  private:
  const ::xpilot::AddPlane& _internal_add_plane() const;
  ::xpilot::AddPlane* _internal_mutable_add_plane();
  public:
  void unsafe_arena_set_allocated_add_plane(
      ::xpilot::AddPlane* add_plane);
  ::xpilot::AddPlane* unsafe_arena_release_add_plane();

  // .xpilot.ChangeModel change_model = 7;
  bool has_change_model() const;
  private:
  bool _internal_has_change_model() const;
  public:
  void clear_change_model();
  const ::xpilot::ChangeModel& change_model() const;
  ::xpilot::ChangeModel* release_change_model();
  ::xpilot::ChangeModel* mutable_change_model();
  void set_allocated_change_model(::xpilot::ChangeModel* change_model);
  private:
  const ::xpilot::ChangeModel& _internal_change_model() const;
  ::xpilot::ChangeModel* _internal_mutable_change_model();
  public:
  void unsafe_arena_set_allocated_change_model(
      ::xpilot::ChangeModel* change_model);
  ::xpilot::ChangeModel* unsafe_arena_release_change_model();

  // .xpilot.PositionUpdate position_update = 8;
  bool has_position_update() const;
  private:
  bool _internal_has_position_update() const;
  public:
  void clear_position_update();
  const ::xpilot::PositionUpdate& position_update() const;
  ::xpilot::PositionUpdate* release_position_update();
  ::xpilot::PositionUpdate* mutable_position_update();
  void set_allocated_position_update(::xpilot::PositionUpdate* position_update);
  private:
  const ::xpilot::PositionUpdate& _internal_position_update() const;
  ::xpilot::PositionUpdate* _internal_mutable_position_update();
  public:
  void unsafe_arena_set_allocated_position_update(
      ::xpilot::PositionUpdate* position_update);
  ::xpilot::PositionUpdate* unsafe_arena_release_position_update();

  // .xpilot.RemovePlane remove_plane = 9;
  bool has_remove_plane() const;
  private:
  bool _internal_has_remove_plane() const;
  public:
  void clear_remove_plane();
  const ::xpilot::RemovePlane& remove_plane() const;
  ::xpilot::RemovePlane* release_remove_plane();
  ::xpilot::RemovePlane* mutable_remove_plane();
  void set_allocated_remove_plane(::xpilot::RemovePlane* remove_plane);
  private:
  const ::xpilot::RemovePlane& _internal_remove_plane() const;
  ::xpilot::RemovePlane* _internal_mutable_remove_plane();
  public:
  void unsafe_arena_set_allocated_remove_plane(
      ::xpilot::RemovePlane* remove_plane);
  ::xpilot::RemovePlane* unsafe_arena_release_remove_plane();

  // .xpilot.RemoveAllPlanes remove_all_planes = 10;
  bool has_remove_all_planes() const;
  private:
  bool _internal_has_remove_all_planes() const;
  public:
  void clear_remove_all_planes();
  const ::xpilot::RemoveAllPlanes& remove_all_planes() const;
  ::xpilot::RemoveAllPlanes* release_remove_all_planes();
  ::xpilot::RemoveAllPlanes* mutable_remove_all_planes();
  void set_allocated_remove_all_planes(::xpilot::RemoveAllPlanes* remove_all_planes);
  private:
  const ::xpilot::RemoveAllPlanes& _internal_remove_all_planes() const;
  ::xpilot::RemoveAllPlanes* _internal_mutable_remove_all_planes();
  public:
  void unsafe_arena_set_allocated_remove_all_planes(
      ::xpilot::RemoveAllPlanes* remove_all_planes);
  ::xpilot::RemoveAllPlanes* unsafe_arena_release_remove_all_planes();

  // .xpilot.NetworkConnected network_connected = 11;
  bool has_network_connected() const;
  private:
  bool _internal_has_network_connected() const;
  public:
  void clear_network_connected();
  const ::xpilot::NetworkConnected& network_connected() const;
  ::xpilot::NetworkConnected* release_network_connected();
  ::xpilot::NetworkConnected* mutable_network_connected();
  void set_allocated_network_connected(::xpilot::NetworkConnected* network_connected);
  private:
  const ::xpilot::NetworkConnected& _internal_network_connected() const;
  ::xpilot::NetworkConnected* _internal_mutable_network_connected();
  public:
  void unsafe_arena_set_allocated_network_connected(
      ::xpilot::NetworkConnected* network_connected);
  ::xpilot::NetworkConnected* unsafe_arena_release_network_connected();

  // .xpilot.NetworkDisconnected network_disconnected = 12;
  bool has_network_disconnected() const;
  private:
  bool _internal_has_network_disconnected() const;
  public:
  void clear_network_disconnected();
  const ::xpilot::NetworkDisconnected& network_disconnected() const;
  ::xpilot::NetworkDisconnected* release_network_disconnected();
  ::xpilot::NetworkDisconnected* mutable_network_disconnected();
  void set_allocated_network_disconnected(::xpilot::NetworkDisconnected* network_disconnected);
  private:
  const ::xpilot::NetworkDisconnected& _internal_network_disconnected() const;
  ::xpilot::NetworkDisconnected* _internal_mutable_network_disconnected();
  public:
  void unsafe_arena_set_allocated_network_disconnected(
      ::xpilot::NetworkDisconnected* network_disconnected);
  ::xpilot::NetworkDisconnected* unsafe_arena_release_network_disconnected();

  // .xpilot.AirplaneConfig airplane_config = 13;
  bool has_airplane_config() const;
  private:
  bool _internal_has_airplane_config() const;
  public:
  void clear_airplane_config();
  const ::xpilot::AirplaneConfig& airplane_config() const;
  ::xpilot::AirplaneConfig* release_airplane_config();
  ::xpilot::AirplaneConfig* mutable_airplane_config();
  void set_allocated_airplane_config(::xpilot::AirplaneConfig* airplane_config);
  private:
  const ::xpilot::AirplaneConfig& _internal_airplane_config() const;
  ::xpilot::AirplaneConfig* _internal_mutable_airplane_config();
  public:
  void unsafe_arena_set_allocated_airplane_config(
      ::xpilot::AirplaneConfig* airplane_config);
  ::xpilot::AirplaneConfig* unsafe_arena_release_airplane_config();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:xpilot.Wrapper)
 private:
  class _Internal;
  void set_has_xplane_data();
  void set_has_plugin_hash();
  void set_has_plugin_version();
  void set_has_csl_validate();
  void set_has_add_plane();
  void set_has_change_model();
  void set_has_position_update();
  void set_has_remove_plane();
  void set_has_remove_all_planes();
  void set_has_network_connected();
  void set_has_network_disconnected();
  void set_has_airplane_config();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  union MsgUnion {
    constexpr MsgUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::xpilot::XplaneData* xplane_data_;
    ::xpilot::PluginHash* plugin_hash_;
    ::xpilot::PluginVersion* plugin_version_;
    ::xpilot::CslValidate* csl_validate_;
    ::xpilot::AddPlane* add_plane_;
    ::xpilot::ChangeModel* change_model_;
    ::xpilot::PositionUpdate* position_update_;
    ::xpilot::RemovePlane* remove_plane_;
    ::xpilot::RemoveAllPlanes* remove_all_planes_;
    ::xpilot::NetworkConnected* network_connected_;
    ::xpilot::NetworkDisconnected* network_disconnected_;
    ::xpilot::AirplaneConfig* airplane_config_;
  } msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_wrapper_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Wrapper

// .google.protobuf.Timestamp timestamp = 1;
inline bool Wrapper::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Wrapper::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Wrapper::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Wrapper::timestamp() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.timestamp)
  return _internal_timestamp();
}
inline void Wrapper::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Wrapper::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Wrapper::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Wrapper::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Wrapper::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.timestamp)
  return _internal_mutable_timestamp();
}
inline void Wrapper::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:xpilot.Wrapper.timestamp)
}

// .xpilot.XplaneData xplane_data = 2;
inline bool Wrapper::_internal_has_xplane_data() const {
  return msg_case() == kXplaneData;
}
inline bool Wrapper::has_xplane_data() const {
  return _internal_has_xplane_data();
}
inline void Wrapper::set_has_xplane_data() {
  _oneof_case_[0] = kXplaneData;
}
inline ::xpilot::XplaneData* Wrapper::release_xplane_data() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.xplane_data)
  if (_internal_has_xplane_data()) {
    clear_has_msg();
      ::xpilot::XplaneData* temp = msg_.xplane_data_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.xplane_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::XplaneData& Wrapper::_internal_xplane_data() const {
  return _internal_has_xplane_data()
      ? *msg_.xplane_data_
      : reinterpret_cast< ::xpilot::XplaneData&>(::xpilot::_XplaneData_default_instance_);
}
inline const ::xpilot::XplaneData& Wrapper::xplane_data() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.xplane_data)
  return _internal_xplane_data();
}
inline ::xpilot::XplaneData* Wrapper::unsafe_arena_release_xplane_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.xplane_data)
  if (_internal_has_xplane_data()) {
    clear_has_msg();
    ::xpilot::XplaneData* temp = msg_.xplane_data_;
    msg_.xplane_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_xplane_data(::xpilot::XplaneData* xplane_data) {
  clear_msg();
  if (xplane_data) {
    set_has_xplane_data();
    msg_.xplane_data_ = xplane_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.xplane_data)
}
inline ::xpilot::XplaneData* Wrapper::_internal_mutable_xplane_data() {
  if (!_internal_has_xplane_data()) {
    clear_msg();
    set_has_xplane_data();
    msg_.xplane_data_ = CreateMaybeMessage< ::xpilot::XplaneData >(GetArena());
  }
  return msg_.xplane_data_;
}
inline ::xpilot::XplaneData* Wrapper::mutable_xplane_data() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.xplane_data)
  return _internal_mutable_xplane_data();
}

// .xpilot.PluginHash plugin_hash = 3;
inline bool Wrapper::_internal_has_plugin_hash() const {
  return msg_case() == kPluginHash;
}
inline bool Wrapper::has_plugin_hash() const {
  return _internal_has_plugin_hash();
}
inline void Wrapper::set_has_plugin_hash() {
  _oneof_case_[0] = kPluginHash;
}
inline ::xpilot::PluginHash* Wrapper::release_plugin_hash() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.plugin_hash)
  if (_internal_has_plugin_hash()) {
    clear_has_msg();
      ::xpilot::PluginHash* temp = msg_.plugin_hash_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.plugin_hash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PluginHash& Wrapper::_internal_plugin_hash() const {
  return _internal_has_plugin_hash()
      ? *msg_.plugin_hash_
      : reinterpret_cast< ::xpilot::PluginHash&>(::xpilot::_PluginHash_default_instance_);
}
inline const ::xpilot::PluginHash& Wrapper::plugin_hash() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.plugin_hash)
  return _internal_plugin_hash();
}
inline ::xpilot::PluginHash* Wrapper::unsafe_arena_release_plugin_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.plugin_hash)
  if (_internal_has_plugin_hash()) {
    clear_has_msg();
    ::xpilot::PluginHash* temp = msg_.plugin_hash_;
    msg_.plugin_hash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_plugin_hash(::xpilot::PluginHash* plugin_hash) {
  clear_msg();
  if (plugin_hash) {
    set_has_plugin_hash();
    msg_.plugin_hash_ = plugin_hash;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.plugin_hash)
}
inline ::xpilot::PluginHash* Wrapper::_internal_mutable_plugin_hash() {
  if (!_internal_has_plugin_hash()) {
    clear_msg();
    set_has_plugin_hash();
    msg_.plugin_hash_ = CreateMaybeMessage< ::xpilot::PluginHash >(GetArena());
  }
  return msg_.plugin_hash_;
}
inline ::xpilot::PluginHash* Wrapper::mutable_plugin_hash() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.plugin_hash)
  return _internal_mutable_plugin_hash();
}

// .xpilot.PluginVersion plugin_version = 4;
inline bool Wrapper::_internal_has_plugin_version() const {
  return msg_case() == kPluginVersion;
}
inline bool Wrapper::has_plugin_version() const {
  return _internal_has_plugin_version();
}
inline void Wrapper::set_has_plugin_version() {
  _oneof_case_[0] = kPluginVersion;
}
inline ::xpilot::PluginVersion* Wrapper::release_plugin_version() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.plugin_version)
  if (_internal_has_plugin_version()) {
    clear_has_msg();
      ::xpilot::PluginVersion* temp = msg_.plugin_version_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.plugin_version_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PluginVersion& Wrapper::_internal_plugin_version() const {
  return _internal_has_plugin_version()
      ? *msg_.plugin_version_
      : reinterpret_cast< ::xpilot::PluginVersion&>(::xpilot::_PluginVersion_default_instance_);
}
inline const ::xpilot::PluginVersion& Wrapper::plugin_version() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.plugin_version)
  return _internal_plugin_version();
}
inline ::xpilot::PluginVersion* Wrapper::unsafe_arena_release_plugin_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.plugin_version)
  if (_internal_has_plugin_version()) {
    clear_has_msg();
    ::xpilot::PluginVersion* temp = msg_.plugin_version_;
    msg_.plugin_version_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_plugin_version(::xpilot::PluginVersion* plugin_version) {
  clear_msg();
  if (plugin_version) {
    set_has_plugin_version();
    msg_.plugin_version_ = plugin_version;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.plugin_version)
}
inline ::xpilot::PluginVersion* Wrapper::_internal_mutable_plugin_version() {
  if (!_internal_has_plugin_version()) {
    clear_msg();
    set_has_plugin_version();
    msg_.plugin_version_ = CreateMaybeMessage< ::xpilot::PluginVersion >(GetArena());
  }
  return msg_.plugin_version_;
}
inline ::xpilot::PluginVersion* Wrapper::mutable_plugin_version() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.plugin_version)
  return _internal_mutable_plugin_version();
}

// .xpilot.CslValidate csl_validate = 5;
inline bool Wrapper::_internal_has_csl_validate() const {
  return msg_case() == kCslValidate;
}
inline bool Wrapper::has_csl_validate() const {
  return _internal_has_csl_validate();
}
inline void Wrapper::set_has_csl_validate() {
  _oneof_case_[0] = kCslValidate;
}
inline ::xpilot::CslValidate* Wrapper::release_csl_validate() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.csl_validate)
  if (_internal_has_csl_validate()) {
    clear_has_msg();
      ::xpilot::CslValidate* temp = msg_.csl_validate_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.csl_validate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::CslValidate& Wrapper::_internal_csl_validate() const {
  return _internal_has_csl_validate()
      ? *msg_.csl_validate_
      : reinterpret_cast< ::xpilot::CslValidate&>(::xpilot::_CslValidate_default_instance_);
}
inline const ::xpilot::CslValidate& Wrapper::csl_validate() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.csl_validate)
  return _internal_csl_validate();
}
inline ::xpilot::CslValidate* Wrapper::unsafe_arena_release_csl_validate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.csl_validate)
  if (_internal_has_csl_validate()) {
    clear_has_msg();
    ::xpilot::CslValidate* temp = msg_.csl_validate_;
    msg_.csl_validate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_csl_validate(::xpilot::CslValidate* csl_validate) {
  clear_msg();
  if (csl_validate) {
    set_has_csl_validate();
    msg_.csl_validate_ = csl_validate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.csl_validate)
}
inline ::xpilot::CslValidate* Wrapper::_internal_mutable_csl_validate() {
  if (!_internal_has_csl_validate()) {
    clear_msg();
    set_has_csl_validate();
    msg_.csl_validate_ = CreateMaybeMessage< ::xpilot::CslValidate >(GetArena());
  }
  return msg_.csl_validate_;
}
inline ::xpilot::CslValidate* Wrapper::mutable_csl_validate() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.csl_validate)
  return _internal_mutable_csl_validate();
}

// .xpilot.AddPlane add_plane = 6;
inline bool Wrapper::_internal_has_add_plane() const {
  return msg_case() == kAddPlane;
}
inline bool Wrapper::has_add_plane() const {
  return _internal_has_add_plane();
}
inline void Wrapper::set_has_add_plane() {
  _oneof_case_[0] = kAddPlane;
}
inline ::xpilot::AddPlane* Wrapper::release_add_plane() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.add_plane)
  if (_internal_has_add_plane()) {
    clear_has_msg();
      ::xpilot::AddPlane* temp = msg_.add_plane_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.add_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::AddPlane& Wrapper::_internal_add_plane() const {
  return _internal_has_add_plane()
      ? *msg_.add_plane_
      : reinterpret_cast< ::xpilot::AddPlane&>(::xpilot::_AddPlane_default_instance_);
}
inline const ::xpilot::AddPlane& Wrapper::add_plane() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.add_plane)
  return _internal_add_plane();
}
inline ::xpilot::AddPlane* Wrapper::unsafe_arena_release_add_plane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.add_plane)
  if (_internal_has_add_plane()) {
    clear_has_msg();
    ::xpilot::AddPlane* temp = msg_.add_plane_;
    msg_.add_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_add_plane(::xpilot::AddPlane* add_plane) {
  clear_msg();
  if (add_plane) {
    set_has_add_plane();
    msg_.add_plane_ = add_plane;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.add_plane)
}
inline ::xpilot::AddPlane* Wrapper::_internal_mutable_add_plane() {
  if (!_internal_has_add_plane()) {
    clear_msg();
    set_has_add_plane();
    msg_.add_plane_ = CreateMaybeMessage< ::xpilot::AddPlane >(GetArena());
  }
  return msg_.add_plane_;
}
inline ::xpilot::AddPlane* Wrapper::mutable_add_plane() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.add_plane)
  return _internal_mutable_add_plane();
}

// .xpilot.ChangeModel change_model = 7;
inline bool Wrapper::_internal_has_change_model() const {
  return msg_case() == kChangeModel;
}
inline bool Wrapper::has_change_model() const {
  return _internal_has_change_model();
}
inline void Wrapper::set_has_change_model() {
  _oneof_case_[0] = kChangeModel;
}
inline ::xpilot::ChangeModel* Wrapper::release_change_model() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.change_model)
  if (_internal_has_change_model()) {
    clear_has_msg();
      ::xpilot::ChangeModel* temp = msg_.change_model_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.change_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::ChangeModel& Wrapper::_internal_change_model() const {
  return _internal_has_change_model()
      ? *msg_.change_model_
      : reinterpret_cast< ::xpilot::ChangeModel&>(::xpilot::_ChangeModel_default_instance_);
}
inline const ::xpilot::ChangeModel& Wrapper::change_model() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.change_model)
  return _internal_change_model();
}
inline ::xpilot::ChangeModel* Wrapper::unsafe_arena_release_change_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.change_model)
  if (_internal_has_change_model()) {
    clear_has_msg();
    ::xpilot::ChangeModel* temp = msg_.change_model_;
    msg_.change_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_change_model(::xpilot::ChangeModel* change_model) {
  clear_msg();
  if (change_model) {
    set_has_change_model();
    msg_.change_model_ = change_model;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.change_model)
}
inline ::xpilot::ChangeModel* Wrapper::_internal_mutable_change_model() {
  if (!_internal_has_change_model()) {
    clear_msg();
    set_has_change_model();
    msg_.change_model_ = CreateMaybeMessage< ::xpilot::ChangeModel >(GetArena());
  }
  return msg_.change_model_;
}
inline ::xpilot::ChangeModel* Wrapper::mutable_change_model() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.change_model)
  return _internal_mutable_change_model();
}

// .xpilot.PositionUpdate position_update = 8;
inline bool Wrapper::_internal_has_position_update() const {
  return msg_case() == kPositionUpdate;
}
inline bool Wrapper::has_position_update() const {
  return _internal_has_position_update();
}
inline void Wrapper::set_has_position_update() {
  _oneof_case_[0] = kPositionUpdate;
}
inline ::xpilot::PositionUpdate* Wrapper::release_position_update() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.position_update)
  if (_internal_has_position_update()) {
    clear_has_msg();
      ::xpilot::PositionUpdate* temp = msg_.position_update_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.position_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PositionUpdate& Wrapper::_internal_position_update() const {
  return _internal_has_position_update()
      ? *msg_.position_update_
      : reinterpret_cast< ::xpilot::PositionUpdate&>(::xpilot::_PositionUpdate_default_instance_);
}
inline const ::xpilot::PositionUpdate& Wrapper::position_update() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.position_update)
  return _internal_position_update();
}
inline ::xpilot::PositionUpdate* Wrapper::unsafe_arena_release_position_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.position_update)
  if (_internal_has_position_update()) {
    clear_has_msg();
    ::xpilot::PositionUpdate* temp = msg_.position_update_;
    msg_.position_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_position_update(::xpilot::PositionUpdate* position_update) {
  clear_msg();
  if (position_update) {
    set_has_position_update();
    msg_.position_update_ = position_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.position_update)
}
inline ::xpilot::PositionUpdate* Wrapper::_internal_mutable_position_update() {
  if (!_internal_has_position_update()) {
    clear_msg();
    set_has_position_update();
    msg_.position_update_ = CreateMaybeMessage< ::xpilot::PositionUpdate >(GetArena());
  }
  return msg_.position_update_;
}
inline ::xpilot::PositionUpdate* Wrapper::mutable_position_update() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.position_update)
  return _internal_mutable_position_update();
}

// .xpilot.RemovePlane remove_plane = 9;
inline bool Wrapper::_internal_has_remove_plane() const {
  return msg_case() == kRemovePlane;
}
inline bool Wrapper::has_remove_plane() const {
  return _internal_has_remove_plane();
}
inline void Wrapper::set_has_remove_plane() {
  _oneof_case_[0] = kRemovePlane;
}
inline ::xpilot::RemovePlane* Wrapper::release_remove_plane() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.remove_plane)
  if (_internal_has_remove_plane()) {
    clear_has_msg();
      ::xpilot::RemovePlane* temp = msg_.remove_plane_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.remove_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::RemovePlane& Wrapper::_internal_remove_plane() const {
  return _internal_has_remove_plane()
      ? *msg_.remove_plane_
      : reinterpret_cast< ::xpilot::RemovePlane&>(::xpilot::_RemovePlane_default_instance_);
}
inline const ::xpilot::RemovePlane& Wrapper::remove_plane() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.remove_plane)
  return _internal_remove_plane();
}
inline ::xpilot::RemovePlane* Wrapper::unsafe_arena_release_remove_plane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.remove_plane)
  if (_internal_has_remove_plane()) {
    clear_has_msg();
    ::xpilot::RemovePlane* temp = msg_.remove_plane_;
    msg_.remove_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_remove_plane(::xpilot::RemovePlane* remove_plane) {
  clear_msg();
  if (remove_plane) {
    set_has_remove_plane();
    msg_.remove_plane_ = remove_plane;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.remove_plane)
}
inline ::xpilot::RemovePlane* Wrapper::_internal_mutable_remove_plane() {
  if (!_internal_has_remove_plane()) {
    clear_msg();
    set_has_remove_plane();
    msg_.remove_plane_ = CreateMaybeMessage< ::xpilot::RemovePlane >(GetArena());
  }
  return msg_.remove_plane_;
}
inline ::xpilot::RemovePlane* Wrapper::mutable_remove_plane() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.remove_plane)
  return _internal_mutable_remove_plane();
}

// .xpilot.RemoveAllPlanes remove_all_planes = 10;
inline bool Wrapper::_internal_has_remove_all_planes() const {
  return msg_case() == kRemoveAllPlanes;
}
inline bool Wrapper::has_remove_all_planes() const {
  return _internal_has_remove_all_planes();
}
inline void Wrapper::set_has_remove_all_planes() {
  _oneof_case_[0] = kRemoveAllPlanes;
}
inline ::xpilot::RemoveAllPlanes* Wrapper::release_remove_all_planes() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.remove_all_planes)
  if (_internal_has_remove_all_planes()) {
    clear_has_msg();
      ::xpilot::RemoveAllPlanes* temp = msg_.remove_all_planes_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.remove_all_planes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::RemoveAllPlanes& Wrapper::_internal_remove_all_planes() const {
  return _internal_has_remove_all_planes()
      ? *msg_.remove_all_planes_
      : reinterpret_cast< ::xpilot::RemoveAllPlanes&>(::xpilot::_RemoveAllPlanes_default_instance_);
}
inline const ::xpilot::RemoveAllPlanes& Wrapper::remove_all_planes() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.remove_all_planes)
  return _internal_remove_all_planes();
}
inline ::xpilot::RemoveAllPlanes* Wrapper::unsafe_arena_release_remove_all_planes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.remove_all_planes)
  if (_internal_has_remove_all_planes()) {
    clear_has_msg();
    ::xpilot::RemoveAllPlanes* temp = msg_.remove_all_planes_;
    msg_.remove_all_planes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_remove_all_planes(::xpilot::RemoveAllPlanes* remove_all_planes) {
  clear_msg();
  if (remove_all_planes) {
    set_has_remove_all_planes();
    msg_.remove_all_planes_ = remove_all_planes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.remove_all_planes)
}
inline ::xpilot::RemoveAllPlanes* Wrapper::_internal_mutable_remove_all_planes() {
  if (!_internal_has_remove_all_planes()) {
    clear_msg();
    set_has_remove_all_planes();
    msg_.remove_all_planes_ = CreateMaybeMessage< ::xpilot::RemoveAllPlanes >(GetArena());
  }
  return msg_.remove_all_planes_;
}
inline ::xpilot::RemoveAllPlanes* Wrapper::mutable_remove_all_planes() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.remove_all_planes)
  return _internal_mutable_remove_all_planes();
}

// .xpilot.NetworkConnected network_connected = 11;
inline bool Wrapper::_internal_has_network_connected() const {
  return msg_case() == kNetworkConnected;
}
inline bool Wrapper::has_network_connected() const {
  return _internal_has_network_connected();
}
inline void Wrapper::set_has_network_connected() {
  _oneof_case_[0] = kNetworkConnected;
}
inline ::xpilot::NetworkConnected* Wrapper::release_network_connected() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.network_connected)
  if (_internal_has_network_connected()) {
    clear_has_msg();
      ::xpilot::NetworkConnected* temp = msg_.network_connected_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.network_connected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::NetworkConnected& Wrapper::_internal_network_connected() const {
  return _internal_has_network_connected()
      ? *msg_.network_connected_
      : reinterpret_cast< ::xpilot::NetworkConnected&>(::xpilot::_NetworkConnected_default_instance_);
}
inline const ::xpilot::NetworkConnected& Wrapper::network_connected() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.network_connected)
  return _internal_network_connected();
}
inline ::xpilot::NetworkConnected* Wrapper::unsafe_arena_release_network_connected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.network_connected)
  if (_internal_has_network_connected()) {
    clear_has_msg();
    ::xpilot::NetworkConnected* temp = msg_.network_connected_;
    msg_.network_connected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_network_connected(::xpilot::NetworkConnected* network_connected) {
  clear_msg();
  if (network_connected) {
    set_has_network_connected();
    msg_.network_connected_ = network_connected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.network_connected)
}
inline ::xpilot::NetworkConnected* Wrapper::_internal_mutable_network_connected() {
  if (!_internal_has_network_connected()) {
    clear_msg();
    set_has_network_connected();
    msg_.network_connected_ = CreateMaybeMessage< ::xpilot::NetworkConnected >(GetArena());
  }
  return msg_.network_connected_;
}
inline ::xpilot::NetworkConnected* Wrapper::mutable_network_connected() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.network_connected)
  return _internal_mutable_network_connected();
}

// .xpilot.NetworkDisconnected network_disconnected = 12;
inline bool Wrapper::_internal_has_network_disconnected() const {
  return msg_case() == kNetworkDisconnected;
}
inline bool Wrapper::has_network_disconnected() const {
  return _internal_has_network_disconnected();
}
inline void Wrapper::set_has_network_disconnected() {
  _oneof_case_[0] = kNetworkDisconnected;
}
inline ::xpilot::NetworkDisconnected* Wrapper::release_network_disconnected() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.network_disconnected)
  if (_internal_has_network_disconnected()) {
    clear_has_msg();
      ::xpilot::NetworkDisconnected* temp = msg_.network_disconnected_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.network_disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::NetworkDisconnected& Wrapper::_internal_network_disconnected() const {
  return _internal_has_network_disconnected()
      ? *msg_.network_disconnected_
      : reinterpret_cast< ::xpilot::NetworkDisconnected&>(::xpilot::_NetworkDisconnected_default_instance_);
}
inline const ::xpilot::NetworkDisconnected& Wrapper::network_disconnected() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.network_disconnected)
  return _internal_network_disconnected();
}
inline ::xpilot::NetworkDisconnected* Wrapper::unsafe_arena_release_network_disconnected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.network_disconnected)
  if (_internal_has_network_disconnected()) {
    clear_has_msg();
    ::xpilot::NetworkDisconnected* temp = msg_.network_disconnected_;
    msg_.network_disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_network_disconnected(::xpilot::NetworkDisconnected* network_disconnected) {
  clear_msg();
  if (network_disconnected) {
    set_has_network_disconnected();
    msg_.network_disconnected_ = network_disconnected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.network_disconnected)
}
inline ::xpilot::NetworkDisconnected* Wrapper::_internal_mutable_network_disconnected() {
  if (!_internal_has_network_disconnected()) {
    clear_msg();
    set_has_network_disconnected();
    msg_.network_disconnected_ = CreateMaybeMessage< ::xpilot::NetworkDisconnected >(GetArena());
  }
  return msg_.network_disconnected_;
}
inline ::xpilot::NetworkDisconnected* Wrapper::mutable_network_disconnected() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.network_disconnected)
  return _internal_mutable_network_disconnected();
}

// .xpilot.AirplaneConfig airplane_config = 13;
inline bool Wrapper::_internal_has_airplane_config() const {
  return msg_case() == kAirplaneConfig;
}
inline bool Wrapper::has_airplane_config() const {
  return _internal_has_airplane_config();
}
inline void Wrapper::set_has_airplane_config() {
  _oneof_case_[0] = kAirplaneConfig;
}
inline ::xpilot::AirplaneConfig* Wrapper::release_airplane_config() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.airplane_config)
  if (_internal_has_airplane_config()) {
    clear_has_msg();
      ::xpilot::AirplaneConfig* temp = msg_.airplane_config_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.airplane_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::AirplaneConfig& Wrapper::_internal_airplane_config() const {
  return _internal_has_airplane_config()
      ? *msg_.airplane_config_
      : reinterpret_cast< ::xpilot::AirplaneConfig&>(::xpilot::_AirplaneConfig_default_instance_);
}
inline const ::xpilot::AirplaneConfig& Wrapper::airplane_config() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.airplane_config)
  return _internal_airplane_config();
}
inline ::xpilot::AirplaneConfig* Wrapper::unsafe_arena_release_airplane_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.airplane_config)
  if (_internal_has_airplane_config()) {
    clear_has_msg();
    ::xpilot::AirplaneConfig* temp = msg_.airplane_config_;
    msg_.airplane_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_airplane_config(::xpilot::AirplaneConfig* airplane_config) {
  clear_msg();
  if (airplane_config) {
    set_has_airplane_config();
    msg_.airplane_config_ = airplane_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.airplane_config)
}
inline ::xpilot::AirplaneConfig* Wrapper::_internal_mutable_airplane_config() {
  if (!_internal_has_airplane_config()) {
    clear_msg();
    set_has_airplane_config();
    msg_.airplane_config_ = CreateMaybeMessage< ::xpilot::AirplaneConfig >(GetArena());
  }
  return msg_.airplane_config_;
}
inline ::xpilot::AirplaneConfig* Wrapper::mutable_airplane_config() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.airplane_config)
  return _internal_mutable_airplane_config();
}

inline bool Wrapper::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Wrapper::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline Wrapper::MsgCase Wrapper::msg_case() const {
  return Wrapper::MsgCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace xpilot

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_wrapper_2eproto
