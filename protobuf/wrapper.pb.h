// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Wrapper.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Wrapper_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Wrapper_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "XplaneDatarefs.pb.h"
#include "PluginHash.pb.h"
#include "PluginVersion.pb.h"
#include "CSLValidate.pb.h"
#include "AddPlane.pb.h"
#include "ChangeModel.pb.h"
#include "PositionUpdate.pb.h"
#include "RemovePlane.pb.h"
#include "RemoveAllPlanes.pb.h"
#include "NetworkConnected.pb.h"
#include "NetworkDisconnected.pb.h"
#include "AirplaneConfig.pb.h"
#include "NearbyControllers.pb.h"
#include "ClearNearbyControllers.pb.h"
#include "PrivateMessageReceived.pb.h"
#include "PrivateMessageSent.pb.h"
#include "SetTransponderCode.pb.h"
#include "FastPositionUpdate.pb.h"
#include "PlaneAddedToSim.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Wrapper_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Wrapper_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Wrapper_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_Wrapper_2eproto_metadata_getter(int index);
namespace xpilot {
class Wrapper;
struct WrapperDefaultTypeInternal;
extern WrapperDefaultTypeInternal _Wrapper_default_instance_;
}  // namespace xpilot
PROTOBUF_NAMESPACE_OPEN
template<> ::xpilot::Wrapper* Arena::CreateMaybeMessage<::xpilot::Wrapper>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace xpilot {

// ===================================================================

class Wrapper PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xpilot.Wrapper) */ {
 public:
  inline Wrapper() : Wrapper(nullptr) {}
  virtual ~Wrapper();
  explicit constexpr Wrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wrapper(const Wrapper& from);
  Wrapper(Wrapper&& from) noexcept
    : Wrapper() {
    *this = ::std::move(from);
  }

  inline Wrapper& operator=(const Wrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wrapper& operator=(Wrapper&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Wrapper& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kXplaneDatarefs = 2,
    kPluginHash = 3,
    kPluginVersion = 4,
    kCslValidate = 5,
    kAddPlane = 6,
    kChangeModel = 7,
    kPositionUpdate = 8,
    kFastPositionUpdate = 9,
    kRemovePlane = 10,
    kRemoveAllPlanes = 11,
    kNetworkConnected = 12,
    kNetworkDisconnected = 13,
    kAirplaneConfig = 14,
    kNearbyControllers = 15,
    kClearNearbyControllers = 16,
    kPrivateMessageReceived = 17,
    kPrivateMessageSent = 18,
    kSetTransponderCode = 19,
    kPlaneAddedToSim = 20,
    MSG_NOT_SET = 0,
  };

  static inline const Wrapper* internal_default_instance() {
    return reinterpret_cast<const Wrapper*>(
               &_Wrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Wrapper& a, Wrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(Wrapper* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Wrapper* New() const final {
    return CreateMaybeMessage<Wrapper>(nullptr);
  }

  Wrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Wrapper>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Wrapper& from);
  void MergeFrom(const Wrapper& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wrapper* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xpilot.Wrapper";
  }
  protected:
  explicit Wrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_Wrapper_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kXplaneDatarefsFieldNumber = 2,
    kPluginHashFieldNumber = 3,
    kPluginVersionFieldNumber = 4,
    kCslValidateFieldNumber = 5,
    kAddPlaneFieldNumber = 6,
    kChangeModelFieldNumber = 7,
    kPositionUpdateFieldNumber = 8,
    kFastPositionUpdateFieldNumber = 9,
    kRemovePlaneFieldNumber = 10,
    kRemoveAllPlanesFieldNumber = 11,
    kNetworkConnectedFieldNumber = 12,
    kNetworkDisconnectedFieldNumber = 13,
    kAirplaneConfigFieldNumber = 14,
    kNearbyControllersFieldNumber = 15,
    kClearNearbyControllersFieldNumber = 16,
    kPrivateMessageReceivedFieldNumber = 17,
    kPrivateMessageSentFieldNumber = 18,
    kSetTransponderCodeFieldNumber = 19,
    kPlaneAddedToSimFieldNumber = 20,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .xpilot.XplaneDatarefs xplane_datarefs = 2;
  bool has_xplane_datarefs() const;
  private:
  bool _internal_has_xplane_datarefs() const;
  public:
  void clear_xplane_datarefs();
  const ::xpilot::XplaneDatarefs& xplane_datarefs() const;
  ::xpilot::XplaneDatarefs* release_xplane_datarefs();
  ::xpilot::XplaneDatarefs* mutable_xplane_datarefs();
  void set_allocated_xplane_datarefs(::xpilot::XplaneDatarefs* xplane_datarefs);
  private:
  const ::xpilot::XplaneDatarefs& _internal_xplane_datarefs() const;
  ::xpilot::XplaneDatarefs* _internal_mutable_xplane_datarefs();
  public:
  void unsafe_arena_set_allocated_xplane_datarefs(
      ::xpilot::XplaneDatarefs* xplane_datarefs);
  ::xpilot::XplaneDatarefs* unsafe_arena_release_xplane_datarefs();

  // .xpilot.PluginHash plugin_hash = 3;
  bool has_plugin_hash() const;
  private:
  bool _internal_has_plugin_hash() const;
  public:
  void clear_plugin_hash();
  const ::xpilot::PluginHash& plugin_hash() const;
  ::xpilot::PluginHash* release_plugin_hash();
  ::xpilot::PluginHash* mutable_plugin_hash();
  void set_allocated_plugin_hash(::xpilot::PluginHash* plugin_hash);
  private:
  const ::xpilot::PluginHash& _internal_plugin_hash() const;
  ::xpilot::PluginHash* _internal_mutable_plugin_hash();
  public:
  void unsafe_arena_set_allocated_plugin_hash(
      ::xpilot::PluginHash* plugin_hash);
  ::xpilot::PluginHash* unsafe_arena_release_plugin_hash();

  // .xpilot.PluginVersion plugin_version = 4;
  bool has_plugin_version() const;
  private:
  bool _internal_has_plugin_version() const;
  public:
  void clear_plugin_version();
  const ::xpilot::PluginVersion& plugin_version() const;
  ::xpilot::PluginVersion* release_plugin_version();
  ::xpilot::PluginVersion* mutable_plugin_version();
  void set_allocated_plugin_version(::xpilot::PluginVersion* plugin_version);
  private:
  const ::xpilot::PluginVersion& _internal_plugin_version() const;
  ::xpilot::PluginVersion* _internal_mutable_plugin_version();
  public:
  void unsafe_arena_set_allocated_plugin_version(
      ::xpilot::PluginVersion* plugin_version);
  ::xpilot::PluginVersion* unsafe_arena_release_plugin_version();

  // .xpilot.CslValidate csl_validate = 5;
  bool has_csl_validate() const;
  private:
  bool _internal_has_csl_validate() const;
  public:
  void clear_csl_validate();
  const ::xpilot::CslValidate& csl_validate() const;
  ::xpilot::CslValidate* release_csl_validate();
  ::xpilot::CslValidate* mutable_csl_validate();
  void set_allocated_csl_validate(::xpilot::CslValidate* csl_validate);
  private:
  const ::xpilot::CslValidate& _internal_csl_validate() const;
  ::xpilot::CslValidate* _internal_mutable_csl_validate();
  public:
  void unsafe_arena_set_allocated_csl_validate(
      ::xpilot::CslValidate* csl_validate);
  ::xpilot::CslValidate* unsafe_arena_release_csl_validate();

  // .xpilot.AddPlane add_plane = 6;
  bool has_add_plane() const;
  private:
  bool _internal_has_add_plane() const;
  public:
  void clear_add_plane();
  const ::xpilot::AddPlane& add_plane() const;
  ::xpilot::AddPlane* release_add_plane();
  ::xpilot::AddPlane* mutable_add_plane();
  void set_allocated_add_plane(::xpilot::AddPlane* add_plane);
  private:
  const ::xpilot::AddPlane& _internal_add_plane() const;
  ::xpilot::AddPlane* _internal_mutable_add_plane();
  public:
  void unsafe_arena_set_allocated_add_plane(
      ::xpilot::AddPlane* add_plane);
  ::xpilot::AddPlane* unsafe_arena_release_add_plane();

  // .xpilot.ChangeModel change_model = 7;
  bool has_change_model() const;
  private:
  bool _internal_has_change_model() const;
  public:
  void clear_change_model();
  const ::xpilot::ChangeModel& change_model() const;
  ::xpilot::ChangeModel* release_change_model();
  ::xpilot::ChangeModel* mutable_change_model();
  void set_allocated_change_model(::xpilot::ChangeModel* change_model);
  private:
  const ::xpilot::ChangeModel& _internal_change_model() const;
  ::xpilot::ChangeModel* _internal_mutable_change_model();
  public:
  void unsafe_arena_set_allocated_change_model(
      ::xpilot::ChangeModel* change_model);
  ::xpilot::ChangeModel* unsafe_arena_release_change_model();

  // .xpilot.PositionUpdate position_update = 8;
  bool has_position_update() const;
  private:
  bool _internal_has_position_update() const;
  public:
  void clear_position_update();
  const ::xpilot::PositionUpdate& position_update() const;
  ::xpilot::PositionUpdate* release_position_update();
  ::xpilot::PositionUpdate* mutable_position_update();
  void set_allocated_position_update(::xpilot::PositionUpdate* position_update);
  private:
  const ::xpilot::PositionUpdate& _internal_position_update() const;
  ::xpilot::PositionUpdate* _internal_mutable_position_update();
  public:
  void unsafe_arena_set_allocated_position_update(
      ::xpilot::PositionUpdate* position_update);
  ::xpilot::PositionUpdate* unsafe_arena_release_position_update();

  // .xpilot.FastPositionUpdate fast_position_update = 9;
  bool has_fast_position_update() const;
  private:
  bool _internal_has_fast_position_update() const;
  public:
  void clear_fast_position_update();
  const ::xpilot::FastPositionUpdate& fast_position_update() const;
  ::xpilot::FastPositionUpdate* release_fast_position_update();
  ::xpilot::FastPositionUpdate* mutable_fast_position_update();
  void set_allocated_fast_position_update(::xpilot::FastPositionUpdate* fast_position_update);
  private:
  const ::xpilot::FastPositionUpdate& _internal_fast_position_update() const;
  ::xpilot::FastPositionUpdate* _internal_mutable_fast_position_update();
  public:
  void unsafe_arena_set_allocated_fast_position_update(
      ::xpilot::FastPositionUpdate* fast_position_update);
  ::xpilot::FastPositionUpdate* unsafe_arena_release_fast_position_update();

  // .xpilot.RemovePlane remove_plane = 10;
  bool has_remove_plane() const;
  private:
  bool _internal_has_remove_plane() const;
  public:
  void clear_remove_plane();
  const ::xpilot::RemovePlane& remove_plane() const;
  ::xpilot::RemovePlane* release_remove_plane();
  ::xpilot::RemovePlane* mutable_remove_plane();
  void set_allocated_remove_plane(::xpilot::RemovePlane* remove_plane);
  private:
  const ::xpilot::RemovePlane& _internal_remove_plane() const;
  ::xpilot::RemovePlane* _internal_mutable_remove_plane();
  public:
  void unsafe_arena_set_allocated_remove_plane(
      ::xpilot::RemovePlane* remove_plane);
  ::xpilot::RemovePlane* unsafe_arena_release_remove_plane();

  // .xpilot.RemoveAllPlanes remove_all_planes = 11;
  bool has_remove_all_planes() const;
  private:
  bool _internal_has_remove_all_planes() const;
  public:
  void clear_remove_all_planes();
  const ::xpilot::RemoveAllPlanes& remove_all_planes() const;
  ::xpilot::RemoveAllPlanes* release_remove_all_planes();
  ::xpilot::RemoveAllPlanes* mutable_remove_all_planes();
  void set_allocated_remove_all_planes(::xpilot::RemoveAllPlanes* remove_all_planes);
  private:
  const ::xpilot::RemoveAllPlanes& _internal_remove_all_planes() const;
  ::xpilot::RemoveAllPlanes* _internal_mutable_remove_all_planes();
  public:
  void unsafe_arena_set_allocated_remove_all_planes(
      ::xpilot::RemoveAllPlanes* remove_all_planes);
  ::xpilot::RemoveAllPlanes* unsafe_arena_release_remove_all_planes();

  // .xpilot.NetworkConnected network_connected = 12;
  bool has_network_connected() const;
  private:
  bool _internal_has_network_connected() const;
  public:
  void clear_network_connected();
  const ::xpilot::NetworkConnected& network_connected() const;
  ::xpilot::NetworkConnected* release_network_connected();
  ::xpilot::NetworkConnected* mutable_network_connected();
  void set_allocated_network_connected(::xpilot::NetworkConnected* network_connected);
  private:
  const ::xpilot::NetworkConnected& _internal_network_connected() const;
  ::xpilot::NetworkConnected* _internal_mutable_network_connected();
  public:
  void unsafe_arena_set_allocated_network_connected(
      ::xpilot::NetworkConnected* network_connected);
  ::xpilot::NetworkConnected* unsafe_arena_release_network_connected();

  // .xpilot.NetworkDisconnected network_disconnected = 13;
  bool has_network_disconnected() const;
  private:
  bool _internal_has_network_disconnected() const;
  public:
  void clear_network_disconnected();
  const ::xpilot::NetworkDisconnected& network_disconnected() const;
  ::xpilot::NetworkDisconnected* release_network_disconnected();
  ::xpilot::NetworkDisconnected* mutable_network_disconnected();
  void set_allocated_network_disconnected(::xpilot::NetworkDisconnected* network_disconnected);
  private:
  const ::xpilot::NetworkDisconnected& _internal_network_disconnected() const;
  ::xpilot::NetworkDisconnected* _internal_mutable_network_disconnected();
  public:
  void unsafe_arena_set_allocated_network_disconnected(
      ::xpilot::NetworkDisconnected* network_disconnected);
  ::xpilot::NetworkDisconnected* unsafe_arena_release_network_disconnected();

  // .xpilot.AirplaneConfig airplane_config = 14;
  bool has_airplane_config() const;
  private:
  bool _internal_has_airplane_config() const;
  public:
  void clear_airplane_config();
  const ::xpilot::AirplaneConfig& airplane_config() const;
  ::xpilot::AirplaneConfig* release_airplane_config();
  ::xpilot::AirplaneConfig* mutable_airplane_config();
  void set_allocated_airplane_config(::xpilot::AirplaneConfig* airplane_config);
  private:
  const ::xpilot::AirplaneConfig& _internal_airplane_config() const;
  ::xpilot::AirplaneConfig* _internal_mutable_airplane_config();
  public:
  void unsafe_arena_set_allocated_airplane_config(
      ::xpilot::AirplaneConfig* airplane_config);
  ::xpilot::AirplaneConfig* unsafe_arena_release_airplane_config();

  // .xpilot.NearbyControllers nearby_controllers = 15;
  bool has_nearby_controllers() const;
  private:
  bool _internal_has_nearby_controllers() const;
  public:
  void clear_nearby_controllers();
  const ::xpilot::NearbyControllers& nearby_controllers() const;
  ::xpilot::NearbyControllers* release_nearby_controllers();
  ::xpilot::NearbyControllers* mutable_nearby_controllers();
  void set_allocated_nearby_controllers(::xpilot::NearbyControllers* nearby_controllers);
  private:
  const ::xpilot::NearbyControllers& _internal_nearby_controllers() const;
  ::xpilot::NearbyControllers* _internal_mutable_nearby_controllers();
  public:
  void unsafe_arena_set_allocated_nearby_controllers(
      ::xpilot::NearbyControllers* nearby_controllers);
  ::xpilot::NearbyControllers* unsafe_arena_release_nearby_controllers();

  // .xpilot.ClearNearbyControllers clear_nearby_controllers = 16;
  bool has_clear_nearby_controllers() const;
  private:
  bool _internal_has_clear_nearby_controllers() const;
  public:
  void clear_clear_nearby_controllers();
  const ::xpilot::ClearNearbyControllers& clear_nearby_controllers() const;
  ::xpilot::ClearNearbyControllers* release_clear_nearby_controllers();
  ::xpilot::ClearNearbyControllers* mutable_clear_nearby_controllers();
  void set_allocated_clear_nearby_controllers(::xpilot::ClearNearbyControllers* clear_nearby_controllers);
  private:
  const ::xpilot::ClearNearbyControllers& _internal_clear_nearby_controllers() const;
  ::xpilot::ClearNearbyControllers* _internal_mutable_clear_nearby_controllers();
  public:
  void unsafe_arena_set_allocated_clear_nearby_controllers(
      ::xpilot::ClearNearbyControllers* clear_nearby_controllers);
  ::xpilot::ClearNearbyControllers* unsafe_arena_release_clear_nearby_controllers();

  // .xpilot.PrivateMessageReceived private_message_received = 17;
  bool has_private_message_received() const;
  private:
  bool _internal_has_private_message_received() const;
  public:
  void clear_private_message_received();
  const ::xpilot::PrivateMessageReceived& private_message_received() const;
  ::xpilot::PrivateMessageReceived* release_private_message_received();
  ::xpilot::PrivateMessageReceived* mutable_private_message_received();
  void set_allocated_private_message_received(::xpilot::PrivateMessageReceived* private_message_received);
  private:
  const ::xpilot::PrivateMessageReceived& _internal_private_message_received() const;
  ::xpilot::PrivateMessageReceived* _internal_mutable_private_message_received();
  public:
  void unsafe_arena_set_allocated_private_message_received(
      ::xpilot::PrivateMessageReceived* private_message_received);
  ::xpilot::PrivateMessageReceived* unsafe_arena_release_private_message_received();

  // .xpilot.PrivateMessageSent private_message_sent = 18;
  bool has_private_message_sent() const;
  private:
  bool _internal_has_private_message_sent() const;
  public:
  void clear_private_message_sent();
  const ::xpilot::PrivateMessageSent& private_message_sent() const;
  ::xpilot::PrivateMessageSent* release_private_message_sent();
  ::xpilot::PrivateMessageSent* mutable_private_message_sent();
  void set_allocated_private_message_sent(::xpilot::PrivateMessageSent* private_message_sent);
  private:
  const ::xpilot::PrivateMessageSent& _internal_private_message_sent() const;
  ::xpilot::PrivateMessageSent* _internal_mutable_private_message_sent();
  public:
  void unsafe_arena_set_allocated_private_message_sent(
      ::xpilot::PrivateMessageSent* private_message_sent);
  ::xpilot::PrivateMessageSent* unsafe_arena_release_private_message_sent();

  // .xpilot.SetTransponderCode set_transponder_code = 19;
  bool has_set_transponder_code() const;
  private:
  bool _internal_has_set_transponder_code() const;
  public:
  void clear_set_transponder_code();
  const ::xpilot::SetTransponderCode& set_transponder_code() const;
  ::xpilot::SetTransponderCode* release_set_transponder_code();
  ::xpilot::SetTransponderCode* mutable_set_transponder_code();
  void set_allocated_set_transponder_code(::xpilot::SetTransponderCode* set_transponder_code);
  private:
  const ::xpilot::SetTransponderCode& _internal_set_transponder_code() const;
  ::xpilot::SetTransponderCode* _internal_mutable_set_transponder_code();
  public:
  void unsafe_arena_set_allocated_set_transponder_code(
      ::xpilot::SetTransponderCode* set_transponder_code);
  ::xpilot::SetTransponderCode* unsafe_arena_release_set_transponder_code();

  // .xpilot.PlaneAddedToSim plane_added_to_sim = 20;
  bool has_plane_added_to_sim() const;
  private:
  bool _internal_has_plane_added_to_sim() const;
  public:
  void clear_plane_added_to_sim();
  const ::xpilot::PlaneAddedToSim& plane_added_to_sim() const;
  ::xpilot::PlaneAddedToSim* release_plane_added_to_sim();
  ::xpilot::PlaneAddedToSim* mutable_plane_added_to_sim();
  void set_allocated_plane_added_to_sim(::xpilot::PlaneAddedToSim* plane_added_to_sim);
  private:
  const ::xpilot::PlaneAddedToSim& _internal_plane_added_to_sim() const;
  ::xpilot::PlaneAddedToSim* _internal_mutable_plane_added_to_sim();
  public:
  void unsafe_arena_set_allocated_plane_added_to_sim(
      ::xpilot::PlaneAddedToSim* plane_added_to_sim);
  ::xpilot::PlaneAddedToSim* unsafe_arena_release_plane_added_to_sim();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:xpilot.Wrapper)
 private:
  class _Internal;
  void set_has_xplane_datarefs();
  void set_has_plugin_hash();
  void set_has_plugin_version();
  void set_has_csl_validate();
  void set_has_add_plane();
  void set_has_change_model();
  void set_has_position_update();
  void set_has_fast_position_update();
  void set_has_remove_plane();
  void set_has_remove_all_planes();
  void set_has_network_connected();
  void set_has_network_disconnected();
  void set_has_airplane_config();
  void set_has_nearby_controllers();
  void set_has_clear_nearby_controllers();
  void set_has_private_message_received();
  void set_has_private_message_sent();
  void set_has_set_transponder_code();
  void set_has_plane_added_to_sim();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  union MsgUnion {
    constexpr MsgUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::xpilot::XplaneDatarefs* xplane_datarefs_;
    ::xpilot::PluginHash* plugin_hash_;
    ::xpilot::PluginVersion* plugin_version_;
    ::xpilot::CslValidate* csl_validate_;
    ::xpilot::AddPlane* add_plane_;
    ::xpilot::ChangeModel* change_model_;
    ::xpilot::PositionUpdate* position_update_;
    ::xpilot::FastPositionUpdate* fast_position_update_;
    ::xpilot::RemovePlane* remove_plane_;
    ::xpilot::RemoveAllPlanes* remove_all_planes_;
    ::xpilot::NetworkConnected* network_connected_;
    ::xpilot::NetworkDisconnected* network_disconnected_;
    ::xpilot::AirplaneConfig* airplane_config_;
    ::xpilot::NearbyControllers* nearby_controllers_;
    ::xpilot::ClearNearbyControllers* clear_nearby_controllers_;
    ::xpilot::PrivateMessageReceived* private_message_received_;
    ::xpilot::PrivateMessageSent* private_message_sent_;
    ::xpilot::SetTransponderCode* set_transponder_code_;
    ::xpilot::PlaneAddedToSim* plane_added_to_sim_;
  } msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_Wrapper_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Wrapper

// .google.protobuf.Timestamp timestamp = 1;
inline bool Wrapper::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Wrapper::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Wrapper::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Wrapper::timestamp() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.timestamp)
  return _internal_timestamp();
}
inline void Wrapper::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Wrapper::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Wrapper::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Wrapper::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Wrapper::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.timestamp)
  return _internal_mutable_timestamp();
}
inline void Wrapper::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:xpilot.Wrapper.timestamp)
}

// .xpilot.XplaneDatarefs xplane_datarefs = 2;
inline bool Wrapper::_internal_has_xplane_datarefs() const {
  return msg_case() == kXplaneDatarefs;
}
inline bool Wrapper::has_xplane_datarefs() const {
  return _internal_has_xplane_datarefs();
}
inline void Wrapper::set_has_xplane_datarefs() {
  _oneof_case_[0] = kXplaneDatarefs;
}
inline ::xpilot::XplaneDatarefs* Wrapper::release_xplane_datarefs() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.xplane_datarefs)
  if (_internal_has_xplane_datarefs()) {
    clear_has_msg();
      ::xpilot::XplaneDatarefs* temp = msg_.xplane_datarefs_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.xplane_datarefs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::XplaneDatarefs& Wrapper::_internal_xplane_datarefs() const {
  return _internal_has_xplane_datarefs()
      ? *msg_.xplane_datarefs_
      : reinterpret_cast< ::xpilot::XplaneDatarefs&>(::xpilot::_XplaneDatarefs_default_instance_);
}
inline const ::xpilot::XplaneDatarefs& Wrapper::xplane_datarefs() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.xplane_datarefs)
  return _internal_xplane_datarefs();
}
inline ::xpilot::XplaneDatarefs* Wrapper::unsafe_arena_release_xplane_datarefs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.xplane_datarefs)
  if (_internal_has_xplane_datarefs()) {
    clear_has_msg();
    ::xpilot::XplaneDatarefs* temp = msg_.xplane_datarefs_;
    msg_.xplane_datarefs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_xplane_datarefs(::xpilot::XplaneDatarefs* xplane_datarefs) {
  clear_msg();
  if (xplane_datarefs) {
    set_has_xplane_datarefs();
    msg_.xplane_datarefs_ = xplane_datarefs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.xplane_datarefs)
}
inline ::xpilot::XplaneDatarefs* Wrapper::_internal_mutable_xplane_datarefs() {
  if (!_internal_has_xplane_datarefs()) {
    clear_msg();
    set_has_xplane_datarefs();
    msg_.xplane_datarefs_ = CreateMaybeMessage< ::xpilot::XplaneDatarefs >(GetArena());
  }
  return msg_.xplane_datarefs_;
}
inline ::xpilot::XplaneDatarefs* Wrapper::mutable_xplane_datarefs() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.xplane_datarefs)
  return _internal_mutable_xplane_datarefs();
}

// .xpilot.PluginHash plugin_hash = 3;
inline bool Wrapper::_internal_has_plugin_hash() const {
  return msg_case() == kPluginHash;
}
inline bool Wrapper::has_plugin_hash() const {
  return _internal_has_plugin_hash();
}
inline void Wrapper::set_has_plugin_hash() {
  _oneof_case_[0] = kPluginHash;
}
inline ::xpilot::PluginHash* Wrapper::release_plugin_hash() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.plugin_hash)
  if (_internal_has_plugin_hash()) {
    clear_has_msg();
      ::xpilot::PluginHash* temp = msg_.plugin_hash_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.plugin_hash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PluginHash& Wrapper::_internal_plugin_hash() const {
  return _internal_has_plugin_hash()
      ? *msg_.plugin_hash_
      : reinterpret_cast< ::xpilot::PluginHash&>(::xpilot::_PluginHash_default_instance_);
}
inline const ::xpilot::PluginHash& Wrapper::plugin_hash() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.plugin_hash)
  return _internal_plugin_hash();
}
inline ::xpilot::PluginHash* Wrapper::unsafe_arena_release_plugin_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.plugin_hash)
  if (_internal_has_plugin_hash()) {
    clear_has_msg();
    ::xpilot::PluginHash* temp = msg_.plugin_hash_;
    msg_.plugin_hash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_plugin_hash(::xpilot::PluginHash* plugin_hash) {
  clear_msg();
  if (plugin_hash) {
    set_has_plugin_hash();
    msg_.plugin_hash_ = plugin_hash;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.plugin_hash)
}
inline ::xpilot::PluginHash* Wrapper::_internal_mutable_plugin_hash() {
  if (!_internal_has_plugin_hash()) {
    clear_msg();
    set_has_plugin_hash();
    msg_.plugin_hash_ = CreateMaybeMessage< ::xpilot::PluginHash >(GetArena());
  }
  return msg_.plugin_hash_;
}
inline ::xpilot::PluginHash* Wrapper::mutable_plugin_hash() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.plugin_hash)
  return _internal_mutable_plugin_hash();
}

// .xpilot.PluginVersion plugin_version = 4;
inline bool Wrapper::_internal_has_plugin_version() const {
  return msg_case() == kPluginVersion;
}
inline bool Wrapper::has_plugin_version() const {
  return _internal_has_plugin_version();
}
inline void Wrapper::set_has_plugin_version() {
  _oneof_case_[0] = kPluginVersion;
}
inline ::xpilot::PluginVersion* Wrapper::release_plugin_version() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.plugin_version)
  if (_internal_has_plugin_version()) {
    clear_has_msg();
      ::xpilot::PluginVersion* temp = msg_.plugin_version_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.plugin_version_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PluginVersion& Wrapper::_internal_plugin_version() const {
  return _internal_has_plugin_version()
      ? *msg_.plugin_version_
      : reinterpret_cast< ::xpilot::PluginVersion&>(::xpilot::_PluginVersion_default_instance_);
}
inline const ::xpilot::PluginVersion& Wrapper::plugin_version() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.plugin_version)
  return _internal_plugin_version();
}
inline ::xpilot::PluginVersion* Wrapper::unsafe_arena_release_plugin_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.plugin_version)
  if (_internal_has_plugin_version()) {
    clear_has_msg();
    ::xpilot::PluginVersion* temp = msg_.plugin_version_;
    msg_.plugin_version_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_plugin_version(::xpilot::PluginVersion* plugin_version) {
  clear_msg();
  if (plugin_version) {
    set_has_plugin_version();
    msg_.plugin_version_ = plugin_version;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.plugin_version)
}
inline ::xpilot::PluginVersion* Wrapper::_internal_mutable_plugin_version() {
  if (!_internal_has_plugin_version()) {
    clear_msg();
    set_has_plugin_version();
    msg_.plugin_version_ = CreateMaybeMessage< ::xpilot::PluginVersion >(GetArena());
  }
  return msg_.plugin_version_;
}
inline ::xpilot::PluginVersion* Wrapper::mutable_plugin_version() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.plugin_version)
  return _internal_mutable_plugin_version();
}

// .xpilot.CslValidate csl_validate = 5;
inline bool Wrapper::_internal_has_csl_validate() const {
  return msg_case() == kCslValidate;
}
inline bool Wrapper::has_csl_validate() const {
  return _internal_has_csl_validate();
}
inline void Wrapper::set_has_csl_validate() {
  _oneof_case_[0] = kCslValidate;
}
inline ::xpilot::CslValidate* Wrapper::release_csl_validate() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.csl_validate)
  if (_internal_has_csl_validate()) {
    clear_has_msg();
      ::xpilot::CslValidate* temp = msg_.csl_validate_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.csl_validate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::CslValidate& Wrapper::_internal_csl_validate() const {
  return _internal_has_csl_validate()
      ? *msg_.csl_validate_
      : reinterpret_cast< ::xpilot::CslValidate&>(::xpilot::_CslValidate_default_instance_);
}
inline const ::xpilot::CslValidate& Wrapper::csl_validate() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.csl_validate)
  return _internal_csl_validate();
}
inline ::xpilot::CslValidate* Wrapper::unsafe_arena_release_csl_validate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.csl_validate)
  if (_internal_has_csl_validate()) {
    clear_has_msg();
    ::xpilot::CslValidate* temp = msg_.csl_validate_;
    msg_.csl_validate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_csl_validate(::xpilot::CslValidate* csl_validate) {
  clear_msg();
  if (csl_validate) {
    set_has_csl_validate();
    msg_.csl_validate_ = csl_validate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.csl_validate)
}
inline ::xpilot::CslValidate* Wrapper::_internal_mutable_csl_validate() {
  if (!_internal_has_csl_validate()) {
    clear_msg();
    set_has_csl_validate();
    msg_.csl_validate_ = CreateMaybeMessage< ::xpilot::CslValidate >(GetArena());
  }
  return msg_.csl_validate_;
}
inline ::xpilot::CslValidate* Wrapper::mutable_csl_validate() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.csl_validate)
  return _internal_mutable_csl_validate();
}

// .xpilot.AddPlane add_plane = 6;
inline bool Wrapper::_internal_has_add_plane() const {
  return msg_case() == kAddPlane;
}
inline bool Wrapper::has_add_plane() const {
  return _internal_has_add_plane();
}
inline void Wrapper::set_has_add_plane() {
  _oneof_case_[0] = kAddPlane;
}
inline ::xpilot::AddPlane* Wrapper::release_add_plane() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.add_plane)
  if (_internal_has_add_plane()) {
    clear_has_msg();
      ::xpilot::AddPlane* temp = msg_.add_plane_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.add_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::AddPlane& Wrapper::_internal_add_plane() const {
  return _internal_has_add_plane()
      ? *msg_.add_plane_
      : reinterpret_cast< ::xpilot::AddPlane&>(::xpilot::_AddPlane_default_instance_);
}
inline const ::xpilot::AddPlane& Wrapper::add_plane() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.add_plane)
  return _internal_add_plane();
}
inline ::xpilot::AddPlane* Wrapper::unsafe_arena_release_add_plane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.add_plane)
  if (_internal_has_add_plane()) {
    clear_has_msg();
    ::xpilot::AddPlane* temp = msg_.add_plane_;
    msg_.add_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_add_plane(::xpilot::AddPlane* add_plane) {
  clear_msg();
  if (add_plane) {
    set_has_add_plane();
    msg_.add_plane_ = add_plane;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.add_plane)
}
inline ::xpilot::AddPlane* Wrapper::_internal_mutable_add_plane() {
  if (!_internal_has_add_plane()) {
    clear_msg();
    set_has_add_plane();
    msg_.add_plane_ = CreateMaybeMessage< ::xpilot::AddPlane >(GetArena());
  }
  return msg_.add_plane_;
}
inline ::xpilot::AddPlane* Wrapper::mutable_add_plane() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.add_plane)
  return _internal_mutable_add_plane();
}

// .xpilot.ChangeModel change_model = 7;
inline bool Wrapper::_internal_has_change_model() const {
  return msg_case() == kChangeModel;
}
inline bool Wrapper::has_change_model() const {
  return _internal_has_change_model();
}
inline void Wrapper::set_has_change_model() {
  _oneof_case_[0] = kChangeModel;
}
inline ::xpilot::ChangeModel* Wrapper::release_change_model() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.change_model)
  if (_internal_has_change_model()) {
    clear_has_msg();
      ::xpilot::ChangeModel* temp = msg_.change_model_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.change_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::ChangeModel& Wrapper::_internal_change_model() const {
  return _internal_has_change_model()
      ? *msg_.change_model_
      : reinterpret_cast< ::xpilot::ChangeModel&>(::xpilot::_ChangeModel_default_instance_);
}
inline const ::xpilot::ChangeModel& Wrapper::change_model() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.change_model)
  return _internal_change_model();
}
inline ::xpilot::ChangeModel* Wrapper::unsafe_arena_release_change_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.change_model)
  if (_internal_has_change_model()) {
    clear_has_msg();
    ::xpilot::ChangeModel* temp = msg_.change_model_;
    msg_.change_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_change_model(::xpilot::ChangeModel* change_model) {
  clear_msg();
  if (change_model) {
    set_has_change_model();
    msg_.change_model_ = change_model;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.change_model)
}
inline ::xpilot::ChangeModel* Wrapper::_internal_mutable_change_model() {
  if (!_internal_has_change_model()) {
    clear_msg();
    set_has_change_model();
    msg_.change_model_ = CreateMaybeMessage< ::xpilot::ChangeModel >(GetArena());
  }
  return msg_.change_model_;
}
inline ::xpilot::ChangeModel* Wrapper::mutable_change_model() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.change_model)
  return _internal_mutable_change_model();
}

// .xpilot.PositionUpdate position_update = 8;
inline bool Wrapper::_internal_has_position_update() const {
  return msg_case() == kPositionUpdate;
}
inline bool Wrapper::has_position_update() const {
  return _internal_has_position_update();
}
inline void Wrapper::set_has_position_update() {
  _oneof_case_[0] = kPositionUpdate;
}
inline ::xpilot::PositionUpdate* Wrapper::release_position_update() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.position_update)
  if (_internal_has_position_update()) {
    clear_has_msg();
      ::xpilot::PositionUpdate* temp = msg_.position_update_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.position_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PositionUpdate& Wrapper::_internal_position_update() const {
  return _internal_has_position_update()
      ? *msg_.position_update_
      : reinterpret_cast< ::xpilot::PositionUpdate&>(::xpilot::_PositionUpdate_default_instance_);
}
inline const ::xpilot::PositionUpdate& Wrapper::position_update() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.position_update)
  return _internal_position_update();
}
inline ::xpilot::PositionUpdate* Wrapper::unsafe_arena_release_position_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.position_update)
  if (_internal_has_position_update()) {
    clear_has_msg();
    ::xpilot::PositionUpdate* temp = msg_.position_update_;
    msg_.position_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_position_update(::xpilot::PositionUpdate* position_update) {
  clear_msg();
  if (position_update) {
    set_has_position_update();
    msg_.position_update_ = position_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.position_update)
}
inline ::xpilot::PositionUpdate* Wrapper::_internal_mutable_position_update() {
  if (!_internal_has_position_update()) {
    clear_msg();
    set_has_position_update();
    msg_.position_update_ = CreateMaybeMessage< ::xpilot::PositionUpdate >(GetArena());
  }
  return msg_.position_update_;
}
inline ::xpilot::PositionUpdate* Wrapper::mutable_position_update() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.position_update)
  return _internal_mutable_position_update();
}

// .xpilot.FastPositionUpdate fast_position_update = 9;
inline bool Wrapper::_internal_has_fast_position_update() const {
  return msg_case() == kFastPositionUpdate;
}
inline bool Wrapper::has_fast_position_update() const {
  return _internal_has_fast_position_update();
}
inline void Wrapper::set_has_fast_position_update() {
  _oneof_case_[0] = kFastPositionUpdate;
}
inline ::xpilot::FastPositionUpdate* Wrapper::release_fast_position_update() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.fast_position_update)
  if (_internal_has_fast_position_update()) {
    clear_has_msg();
      ::xpilot::FastPositionUpdate* temp = msg_.fast_position_update_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.fast_position_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::FastPositionUpdate& Wrapper::_internal_fast_position_update() const {
  return _internal_has_fast_position_update()
      ? *msg_.fast_position_update_
      : reinterpret_cast< ::xpilot::FastPositionUpdate&>(::xpilot::_FastPositionUpdate_default_instance_);
}
inline const ::xpilot::FastPositionUpdate& Wrapper::fast_position_update() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.fast_position_update)
  return _internal_fast_position_update();
}
inline ::xpilot::FastPositionUpdate* Wrapper::unsafe_arena_release_fast_position_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.fast_position_update)
  if (_internal_has_fast_position_update()) {
    clear_has_msg();
    ::xpilot::FastPositionUpdate* temp = msg_.fast_position_update_;
    msg_.fast_position_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_fast_position_update(::xpilot::FastPositionUpdate* fast_position_update) {
  clear_msg();
  if (fast_position_update) {
    set_has_fast_position_update();
    msg_.fast_position_update_ = fast_position_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.fast_position_update)
}
inline ::xpilot::FastPositionUpdate* Wrapper::_internal_mutable_fast_position_update() {
  if (!_internal_has_fast_position_update()) {
    clear_msg();
    set_has_fast_position_update();
    msg_.fast_position_update_ = CreateMaybeMessage< ::xpilot::FastPositionUpdate >(GetArena());
  }
  return msg_.fast_position_update_;
}
inline ::xpilot::FastPositionUpdate* Wrapper::mutable_fast_position_update() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.fast_position_update)
  return _internal_mutable_fast_position_update();
}

// .xpilot.RemovePlane remove_plane = 10;
inline bool Wrapper::_internal_has_remove_plane() const {
  return msg_case() == kRemovePlane;
}
inline bool Wrapper::has_remove_plane() const {
  return _internal_has_remove_plane();
}
inline void Wrapper::set_has_remove_plane() {
  _oneof_case_[0] = kRemovePlane;
}
inline ::xpilot::RemovePlane* Wrapper::release_remove_plane() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.remove_plane)
  if (_internal_has_remove_plane()) {
    clear_has_msg();
      ::xpilot::RemovePlane* temp = msg_.remove_plane_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.remove_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::RemovePlane& Wrapper::_internal_remove_plane() const {
  return _internal_has_remove_plane()
      ? *msg_.remove_plane_
      : reinterpret_cast< ::xpilot::RemovePlane&>(::xpilot::_RemovePlane_default_instance_);
}
inline const ::xpilot::RemovePlane& Wrapper::remove_plane() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.remove_plane)
  return _internal_remove_plane();
}
inline ::xpilot::RemovePlane* Wrapper::unsafe_arena_release_remove_plane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.remove_plane)
  if (_internal_has_remove_plane()) {
    clear_has_msg();
    ::xpilot::RemovePlane* temp = msg_.remove_plane_;
    msg_.remove_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_remove_plane(::xpilot::RemovePlane* remove_plane) {
  clear_msg();
  if (remove_plane) {
    set_has_remove_plane();
    msg_.remove_plane_ = remove_plane;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.remove_plane)
}
inline ::xpilot::RemovePlane* Wrapper::_internal_mutable_remove_plane() {
  if (!_internal_has_remove_plane()) {
    clear_msg();
    set_has_remove_plane();
    msg_.remove_plane_ = CreateMaybeMessage< ::xpilot::RemovePlane >(GetArena());
  }
  return msg_.remove_plane_;
}
inline ::xpilot::RemovePlane* Wrapper::mutable_remove_plane() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.remove_plane)
  return _internal_mutable_remove_plane();
}

// .xpilot.RemoveAllPlanes remove_all_planes = 11;
inline bool Wrapper::_internal_has_remove_all_planes() const {
  return msg_case() == kRemoveAllPlanes;
}
inline bool Wrapper::has_remove_all_planes() const {
  return _internal_has_remove_all_planes();
}
inline void Wrapper::set_has_remove_all_planes() {
  _oneof_case_[0] = kRemoveAllPlanes;
}
inline ::xpilot::RemoveAllPlanes* Wrapper::release_remove_all_planes() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.remove_all_planes)
  if (_internal_has_remove_all_planes()) {
    clear_has_msg();
      ::xpilot::RemoveAllPlanes* temp = msg_.remove_all_planes_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.remove_all_planes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::RemoveAllPlanes& Wrapper::_internal_remove_all_planes() const {
  return _internal_has_remove_all_planes()
      ? *msg_.remove_all_planes_
      : reinterpret_cast< ::xpilot::RemoveAllPlanes&>(::xpilot::_RemoveAllPlanes_default_instance_);
}
inline const ::xpilot::RemoveAllPlanes& Wrapper::remove_all_planes() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.remove_all_planes)
  return _internal_remove_all_planes();
}
inline ::xpilot::RemoveAllPlanes* Wrapper::unsafe_arena_release_remove_all_planes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.remove_all_planes)
  if (_internal_has_remove_all_planes()) {
    clear_has_msg();
    ::xpilot::RemoveAllPlanes* temp = msg_.remove_all_planes_;
    msg_.remove_all_planes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_remove_all_planes(::xpilot::RemoveAllPlanes* remove_all_planes) {
  clear_msg();
  if (remove_all_planes) {
    set_has_remove_all_planes();
    msg_.remove_all_planes_ = remove_all_planes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.remove_all_planes)
}
inline ::xpilot::RemoveAllPlanes* Wrapper::_internal_mutable_remove_all_planes() {
  if (!_internal_has_remove_all_planes()) {
    clear_msg();
    set_has_remove_all_planes();
    msg_.remove_all_planes_ = CreateMaybeMessage< ::xpilot::RemoveAllPlanes >(GetArena());
  }
  return msg_.remove_all_planes_;
}
inline ::xpilot::RemoveAllPlanes* Wrapper::mutable_remove_all_planes() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.remove_all_planes)
  return _internal_mutable_remove_all_planes();
}

// .xpilot.NetworkConnected network_connected = 12;
inline bool Wrapper::_internal_has_network_connected() const {
  return msg_case() == kNetworkConnected;
}
inline bool Wrapper::has_network_connected() const {
  return _internal_has_network_connected();
}
inline void Wrapper::set_has_network_connected() {
  _oneof_case_[0] = kNetworkConnected;
}
inline ::xpilot::NetworkConnected* Wrapper::release_network_connected() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.network_connected)
  if (_internal_has_network_connected()) {
    clear_has_msg();
      ::xpilot::NetworkConnected* temp = msg_.network_connected_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.network_connected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::NetworkConnected& Wrapper::_internal_network_connected() const {
  return _internal_has_network_connected()
      ? *msg_.network_connected_
      : reinterpret_cast< ::xpilot::NetworkConnected&>(::xpilot::_NetworkConnected_default_instance_);
}
inline const ::xpilot::NetworkConnected& Wrapper::network_connected() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.network_connected)
  return _internal_network_connected();
}
inline ::xpilot::NetworkConnected* Wrapper::unsafe_arena_release_network_connected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.network_connected)
  if (_internal_has_network_connected()) {
    clear_has_msg();
    ::xpilot::NetworkConnected* temp = msg_.network_connected_;
    msg_.network_connected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_network_connected(::xpilot::NetworkConnected* network_connected) {
  clear_msg();
  if (network_connected) {
    set_has_network_connected();
    msg_.network_connected_ = network_connected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.network_connected)
}
inline ::xpilot::NetworkConnected* Wrapper::_internal_mutable_network_connected() {
  if (!_internal_has_network_connected()) {
    clear_msg();
    set_has_network_connected();
    msg_.network_connected_ = CreateMaybeMessage< ::xpilot::NetworkConnected >(GetArena());
  }
  return msg_.network_connected_;
}
inline ::xpilot::NetworkConnected* Wrapper::mutable_network_connected() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.network_connected)
  return _internal_mutable_network_connected();
}

// .xpilot.NetworkDisconnected network_disconnected = 13;
inline bool Wrapper::_internal_has_network_disconnected() const {
  return msg_case() == kNetworkDisconnected;
}
inline bool Wrapper::has_network_disconnected() const {
  return _internal_has_network_disconnected();
}
inline void Wrapper::set_has_network_disconnected() {
  _oneof_case_[0] = kNetworkDisconnected;
}
inline ::xpilot::NetworkDisconnected* Wrapper::release_network_disconnected() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.network_disconnected)
  if (_internal_has_network_disconnected()) {
    clear_has_msg();
      ::xpilot::NetworkDisconnected* temp = msg_.network_disconnected_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.network_disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::NetworkDisconnected& Wrapper::_internal_network_disconnected() const {
  return _internal_has_network_disconnected()
      ? *msg_.network_disconnected_
      : reinterpret_cast< ::xpilot::NetworkDisconnected&>(::xpilot::_NetworkDisconnected_default_instance_);
}
inline const ::xpilot::NetworkDisconnected& Wrapper::network_disconnected() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.network_disconnected)
  return _internal_network_disconnected();
}
inline ::xpilot::NetworkDisconnected* Wrapper::unsafe_arena_release_network_disconnected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.network_disconnected)
  if (_internal_has_network_disconnected()) {
    clear_has_msg();
    ::xpilot::NetworkDisconnected* temp = msg_.network_disconnected_;
    msg_.network_disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_network_disconnected(::xpilot::NetworkDisconnected* network_disconnected) {
  clear_msg();
  if (network_disconnected) {
    set_has_network_disconnected();
    msg_.network_disconnected_ = network_disconnected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.network_disconnected)
}
inline ::xpilot::NetworkDisconnected* Wrapper::_internal_mutable_network_disconnected() {
  if (!_internal_has_network_disconnected()) {
    clear_msg();
    set_has_network_disconnected();
    msg_.network_disconnected_ = CreateMaybeMessage< ::xpilot::NetworkDisconnected >(GetArena());
  }
  return msg_.network_disconnected_;
}
inline ::xpilot::NetworkDisconnected* Wrapper::mutable_network_disconnected() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.network_disconnected)
  return _internal_mutable_network_disconnected();
}

// .xpilot.AirplaneConfig airplane_config = 14;
inline bool Wrapper::_internal_has_airplane_config() const {
  return msg_case() == kAirplaneConfig;
}
inline bool Wrapper::has_airplane_config() const {
  return _internal_has_airplane_config();
}
inline void Wrapper::set_has_airplane_config() {
  _oneof_case_[0] = kAirplaneConfig;
}
inline ::xpilot::AirplaneConfig* Wrapper::release_airplane_config() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.airplane_config)
  if (_internal_has_airplane_config()) {
    clear_has_msg();
      ::xpilot::AirplaneConfig* temp = msg_.airplane_config_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.airplane_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::AirplaneConfig& Wrapper::_internal_airplane_config() const {
  return _internal_has_airplane_config()
      ? *msg_.airplane_config_
      : reinterpret_cast< ::xpilot::AirplaneConfig&>(::xpilot::_AirplaneConfig_default_instance_);
}
inline const ::xpilot::AirplaneConfig& Wrapper::airplane_config() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.airplane_config)
  return _internal_airplane_config();
}
inline ::xpilot::AirplaneConfig* Wrapper::unsafe_arena_release_airplane_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.airplane_config)
  if (_internal_has_airplane_config()) {
    clear_has_msg();
    ::xpilot::AirplaneConfig* temp = msg_.airplane_config_;
    msg_.airplane_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_airplane_config(::xpilot::AirplaneConfig* airplane_config) {
  clear_msg();
  if (airplane_config) {
    set_has_airplane_config();
    msg_.airplane_config_ = airplane_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.airplane_config)
}
inline ::xpilot::AirplaneConfig* Wrapper::_internal_mutable_airplane_config() {
  if (!_internal_has_airplane_config()) {
    clear_msg();
    set_has_airplane_config();
    msg_.airplane_config_ = CreateMaybeMessage< ::xpilot::AirplaneConfig >(GetArena());
  }
  return msg_.airplane_config_;
}
inline ::xpilot::AirplaneConfig* Wrapper::mutable_airplane_config() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.airplane_config)
  return _internal_mutable_airplane_config();
}

// .xpilot.NearbyControllers nearby_controllers = 15;
inline bool Wrapper::_internal_has_nearby_controllers() const {
  return msg_case() == kNearbyControllers;
}
inline bool Wrapper::has_nearby_controllers() const {
  return _internal_has_nearby_controllers();
}
inline void Wrapper::set_has_nearby_controllers() {
  _oneof_case_[0] = kNearbyControllers;
}
inline ::xpilot::NearbyControllers* Wrapper::release_nearby_controllers() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.nearby_controllers)
  if (_internal_has_nearby_controllers()) {
    clear_has_msg();
      ::xpilot::NearbyControllers* temp = msg_.nearby_controllers_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.nearby_controllers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::NearbyControllers& Wrapper::_internal_nearby_controllers() const {
  return _internal_has_nearby_controllers()
      ? *msg_.nearby_controllers_
      : reinterpret_cast< ::xpilot::NearbyControllers&>(::xpilot::_NearbyControllers_default_instance_);
}
inline const ::xpilot::NearbyControllers& Wrapper::nearby_controllers() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.nearby_controllers)
  return _internal_nearby_controllers();
}
inline ::xpilot::NearbyControllers* Wrapper::unsafe_arena_release_nearby_controllers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.nearby_controllers)
  if (_internal_has_nearby_controllers()) {
    clear_has_msg();
    ::xpilot::NearbyControllers* temp = msg_.nearby_controllers_;
    msg_.nearby_controllers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_nearby_controllers(::xpilot::NearbyControllers* nearby_controllers) {
  clear_msg();
  if (nearby_controllers) {
    set_has_nearby_controllers();
    msg_.nearby_controllers_ = nearby_controllers;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.nearby_controllers)
}
inline ::xpilot::NearbyControllers* Wrapper::_internal_mutable_nearby_controllers() {
  if (!_internal_has_nearby_controllers()) {
    clear_msg();
    set_has_nearby_controllers();
    msg_.nearby_controllers_ = CreateMaybeMessage< ::xpilot::NearbyControllers >(GetArena());
  }
  return msg_.nearby_controllers_;
}
inline ::xpilot::NearbyControllers* Wrapper::mutable_nearby_controllers() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.nearby_controllers)
  return _internal_mutable_nearby_controllers();
}

// .xpilot.ClearNearbyControllers clear_nearby_controllers = 16;
inline bool Wrapper::_internal_has_clear_nearby_controllers() const {
  return msg_case() == kClearNearbyControllers;
}
inline bool Wrapper::has_clear_nearby_controllers() const {
  return _internal_has_clear_nearby_controllers();
}
inline void Wrapper::set_has_clear_nearby_controllers() {
  _oneof_case_[0] = kClearNearbyControllers;
}
inline ::xpilot::ClearNearbyControllers* Wrapper::release_clear_nearby_controllers() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.clear_nearby_controllers)
  if (_internal_has_clear_nearby_controllers()) {
    clear_has_msg();
      ::xpilot::ClearNearbyControllers* temp = msg_.clear_nearby_controllers_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.clear_nearby_controllers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::ClearNearbyControllers& Wrapper::_internal_clear_nearby_controllers() const {
  return _internal_has_clear_nearby_controllers()
      ? *msg_.clear_nearby_controllers_
      : reinterpret_cast< ::xpilot::ClearNearbyControllers&>(::xpilot::_ClearNearbyControllers_default_instance_);
}
inline const ::xpilot::ClearNearbyControllers& Wrapper::clear_nearby_controllers() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.clear_nearby_controllers)
  return _internal_clear_nearby_controllers();
}
inline ::xpilot::ClearNearbyControllers* Wrapper::unsafe_arena_release_clear_nearby_controllers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.clear_nearby_controllers)
  if (_internal_has_clear_nearby_controllers()) {
    clear_has_msg();
    ::xpilot::ClearNearbyControllers* temp = msg_.clear_nearby_controllers_;
    msg_.clear_nearby_controllers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_clear_nearby_controllers(::xpilot::ClearNearbyControllers* clear_nearby_controllers) {
  clear_msg();
  if (clear_nearby_controllers) {
    set_has_clear_nearby_controllers();
    msg_.clear_nearby_controllers_ = clear_nearby_controllers;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.clear_nearby_controllers)
}
inline ::xpilot::ClearNearbyControllers* Wrapper::_internal_mutable_clear_nearby_controllers() {
  if (!_internal_has_clear_nearby_controllers()) {
    clear_msg();
    set_has_clear_nearby_controllers();
    msg_.clear_nearby_controllers_ = CreateMaybeMessage< ::xpilot::ClearNearbyControllers >(GetArena());
  }
  return msg_.clear_nearby_controllers_;
}
inline ::xpilot::ClearNearbyControllers* Wrapper::mutable_clear_nearby_controllers() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.clear_nearby_controllers)
  return _internal_mutable_clear_nearby_controllers();
}

// .xpilot.PrivateMessageReceived private_message_received = 17;
inline bool Wrapper::_internal_has_private_message_received() const {
  return msg_case() == kPrivateMessageReceived;
}
inline bool Wrapper::has_private_message_received() const {
  return _internal_has_private_message_received();
}
inline void Wrapper::set_has_private_message_received() {
  _oneof_case_[0] = kPrivateMessageReceived;
}
inline ::xpilot::PrivateMessageReceived* Wrapper::release_private_message_received() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.private_message_received)
  if (_internal_has_private_message_received()) {
    clear_has_msg();
      ::xpilot::PrivateMessageReceived* temp = msg_.private_message_received_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.private_message_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PrivateMessageReceived& Wrapper::_internal_private_message_received() const {
  return _internal_has_private_message_received()
      ? *msg_.private_message_received_
      : reinterpret_cast< ::xpilot::PrivateMessageReceived&>(::xpilot::_PrivateMessageReceived_default_instance_);
}
inline const ::xpilot::PrivateMessageReceived& Wrapper::private_message_received() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.private_message_received)
  return _internal_private_message_received();
}
inline ::xpilot::PrivateMessageReceived* Wrapper::unsafe_arena_release_private_message_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.private_message_received)
  if (_internal_has_private_message_received()) {
    clear_has_msg();
    ::xpilot::PrivateMessageReceived* temp = msg_.private_message_received_;
    msg_.private_message_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_private_message_received(::xpilot::PrivateMessageReceived* private_message_received) {
  clear_msg();
  if (private_message_received) {
    set_has_private_message_received();
    msg_.private_message_received_ = private_message_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.private_message_received)
}
inline ::xpilot::PrivateMessageReceived* Wrapper::_internal_mutable_private_message_received() {
  if (!_internal_has_private_message_received()) {
    clear_msg();
    set_has_private_message_received();
    msg_.private_message_received_ = CreateMaybeMessage< ::xpilot::PrivateMessageReceived >(GetArena());
  }
  return msg_.private_message_received_;
}
inline ::xpilot::PrivateMessageReceived* Wrapper::mutable_private_message_received() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.private_message_received)
  return _internal_mutable_private_message_received();
}

// .xpilot.PrivateMessageSent private_message_sent = 18;
inline bool Wrapper::_internal_has_private_message_sent() const {
  return msg_case() == kPrivateMessageSent;
}
inline bool Wrapper::has_private_message_sent() const {
  return _internal_has_private_message_sent();
}
inline void Wrapper::set_has_private_message_sent() {
  _oneof_case_[0] = kPrivateMessageSent;
}
inline ::xpilot::PrivateMessageSent* Wrapper::release_private_message_sent() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.private_message_sent)
  if (_internal_has_private_message_sent()) {
    clear_has_msg();
      ::xpilot::PrivateMessageSent* temp = msg_.private_message_sent_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.private_message_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PrivateMessageSent& Wrapper::_internal_private_message_sent() const {
  return _internal_has_private_message_sent()
      ? *msg_.private_message_sent_
      : reinterpret_cast< ::xpilot::PrivateMessageSent&>(::xpilot::_PrivateMessageSent_default_instance_);
}
inline const ::xpilot::PrivateMessageSent& Wrapper::private_message_sent() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.private_message_sent)
  return _internal_private_message_sent();
}
inline ::xpilot::PrivateMessageSent* Wrapper::unsafe_arena_release_private_message_sent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.private_message_sent)
  if (_internal_has_private_message_sent()) {
    clear_has_msg();
    ::xpilot::PrivateMessageSent* temp = msg_.private_message_sent_;
    msg_.private_message_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_private_message_sent(::xpilot::PrivateMessageSent* private_message_sent) {
  clear_msg();
  if (private_message_sent) {
    set_has_private_message_sent();
    msg_.private_message_sent_ = private_message_sent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.private_message_sent)
}
inline ::xpilot::PrivateMessageSent* Wrapper::_internal_mutable_private_message_sent() {
  if (!_internal_has_private_message_sent()) {
    clear_msg();
    set_has_private_message_sent();
    msg_.private_message_sent_ = CreateMaybeMessage< ::xpilot::PrivateMessageSent >(GetArena());
  }
  return msg_.private_message_sent_;
}
inline ::xpilot::PrivateMessageSent* Wrapper::mutable_private_message_sent() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.private_message_sent)
  return _internal_mutable_private_message_sent();
}

// .xpilot.SetTransponderCode set_transponder_code = 19;
inline bool Wrapper::_internal_has_set_transponder_code() const {
  return msg_case() == kSetTransponderCode;
}
inline bool Wrapper::has_set_transponder_code() const {
  return _internal_has_set_transponder_code();
}
inline void Wrapper::set_has_set_transponder_code() {
  _oneof_case_[0] = kSetTransponderCode;
}
inline ::xpilot::SetTransponderCode* Wrapper::release_set_transponder_code() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.set_transponder_code)
  if (_internal_has_set_transponder_code()) {
    clear_has_msg();
      ::xpilot::SetTransponderCode* temp = msg_.set_transponder_code_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.set_transponder_code_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::SetTransponderCode& Wrapper::_internal_set_transponder_code() const {
  return _internal_has_set_transponder_code()
      ? *msg_.set_transponder_code_
      : reinterpret_cast< ::xpilot::SetTransponderCode&>(::xpilot::_SetTransponderCode_default_instance_);
}
inline const ::xpilot::SetTransponderCode& Wrapper::set_transponder_code() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.set_transponder_code)
  return _internal_set_transponder_code();
}
inline ::xpilot::SetTransponderCode* Wrapper::unsafe_arena_release_set_transponder_code() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.set_transponder_code)
  if (_internal_has_set_transponder_code()) {
    clear_has_msg();
    ::xpilot::SetTransponderCode* temp = msg_.set_transponder_code_;
    msg_.set_transponder_code_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_set_transponder_code(::xpilot::SetTransponderCode* set_transponder_code) {
  clear_msg();
  if (set_transponder_code) {
    set_has_set_transponder_code();
    msg_.set_transponder_code_ = set_transponder_code;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.set_transponder_code)
}
inline ::xpilot::SetTransponderCode* Wrapper::_internal_mutable_set_transponder_code() {
  if (!_internal_has_set_transponder_code()) {
    clear_msg();
    set_has_set_transponder_code();
    msg_.set_transponder_code_ = CreateMaybeMessage< ::xpilot::SetTransponderCode >(GetArena());
  }
  return msg_.set_transponder_code_;
}
inline ::xpilot::SetTransponderCode* Wrapper::mutable_set_transponder_code() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.set_transponder_code)
  return _internal_mutable_set_transponder_code();
}

// .xpilot.PlaneAddedToSim plane_added_to_sim = 20;
inline bool Wrapper::_internal_has_plane_added_to_sim() const {
  return msg_case() == kPlaneAddedToSim;
}
inline bool Wrapper::has_plane_added_to_sim() const {
  return _internal_has_plane_added_to_sim();
}
inline void Wrapper::set_has_plane_added_to_sim() {
  _oneof_case_[0] = kPlaneAddedToSim;
}
inline ::xpilot::PlaneAddedToSim* Wrapper::release_plane_added_to_sim() {
  // @@protoc_insertion_point(field_release:xpilot.Wrapper.plane_added_to_sim)
  if (_internal_has_plane_added_to_sim()) {
    clear_has_msg();
      ::xpilot::PlaneAddedToSim* temp = msg_.plane_added_to_sim_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.plane_added_to_sim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xpilot::PlaneAddedToSim& Wrapper::_internal_plane_added_to_sim() const {
  return _internal_has_plane_added_to_sim()
      ? *msg_.plane_added_to_sim_
      : reinterpret_cast< ::xpilot::PlaneAddedToSim&>(::xpilot::_PlaneAddedToSim_default_instance_);
}
inline const ::xpilot::PlaneAddedToSim& Wrapper::plane_added_to_sim() const {
  // @@protoc_insertion_point(field_get:xpilot.Wrapper.plane_added_to_sim)
  return _internal_plane_added_to_sim();
}
inline ::xpilot::PlaneAddedToSim* Wrapper::unsafe_arena_release_plane_added_to_sim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xpilot.Wrapper.plane_added_to_sim)
  if (_internal_has_plane_added_to_sim()) {
    clear_has_msg();
    ::xpilot::PlaneAddedToSim* temp = msg_.plane_added_to_sim_;
    msg_.plane_added_to_sim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_plane_added_to_sim(::xpilot::PlaneAddedToSim* plane_added_to_sim) {
  clear_msg();
  if (plane_added_to_sim) {
    set_has_plane_added_to_sim();
    msg_.plane_added_to_sim_ = plane_added_to_sim;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xpilot.Wrapper.plane_added_to_sim)
}
inline ::xpilot::PlaneAddedToSim* Wrapper::_internal_mutable_plane_added_to_sim() {
  if (!_internal_has_plane_added_to_sim()) {
    clear_msg();
    set_has_plane_added_to_sim();
    msg_.plane_added_to_sim_ = CreateMaybeMessage< ::xpilot::PlaneAddedToSim >(GetArena());
  }
  return msg_.plane_added_to_sim_;
}
inline ::xpilot::PlaneAddedToSim* Wrapper::mutable_plane_added_to_sim() {
  // @@protoc_insertion_point(field_mutable:xpilot.Wrapper.plane_added_to_sim)
  return _internal_mutable_plane_added_to_sim();
}

inline bool Wrapper::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Wrapper::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline Wrapper::MsgCase Wrapper::msg_case() const {
  return Wrapper::MsgCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace xpilot

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Wrapper_2eproto
